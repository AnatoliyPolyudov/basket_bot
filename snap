

===== console_observer.py =====


from observer import Observer
from datetime import datetime

class ConsoleObserver(Observer):
    def update(self, data):
        print(f"[{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}] Observer received update:")
        print(f"  Signal: {data['signal']}, Z-score: {data['z']:.4f}, Spread: {data['spread']:.6f}")


===== monitor.py =====


import ccxt
import pandas as pd
import numpy as np
import time
import logging
from datetime import datetime
from observer import Subject
from console_observer import ConsoleObserver
from telegram_observer import TelegramObserver

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

class OKXBasketMonitor(Subject):
    def __init__(self):
        super().__init__()
        self.exchange = ccxt.okx({
            "enableRateLimit": True,
            "options": {"defaultType": "swap"},
            "sandbox": False
        })
        self.target = "BTC/USDT:USDT"
        self.basket_symbols = ["ETH/USDT:USDT","BNB/USDT:USDT","SOL/USDT:USDT","XRP/USDT:USDT"]
        self.basket_weights = []
        self.historical_data = {}
        self.lookback_days = 30

    def fetch_historical_data(self):
        logger.info("Fetching historical data from OKX...")
        for symbol in [self.target] + self.basket_symbols:
            try:
                since = self.exchange.parse8601(
                    (datetime.utcnow() - pd.Timedelta(days=self.lookback_days)).isoformat()
                )
                ohlcv = self.exchange.fetch_ohlcv(symbol, "1d", since=since, limit=30)
                if not ohlcv:
                    logger.warning(f"No data for {symbol}")
                    continue
                self.historical_data[symbol] = [c[4] for c in ohlcv]
                logger.info(f"Loaded {len(self.historical_data[symbol])} days for {symbol}")
            except Exception as e:
                logger.warning(f"Error loading {symbol}: {e}")

        valid = [s for s in [self.target]+self.basket_symbols if s in self.historical_data and len(self.historical_data[s])>=10]
        if len(valid) < 3:
            logger.error("Not enough valid symbols for analysis.")
            return False
        return True

    def calculate_basket_weights(self):
        correlations, valid = [], []
        for symbol in self.basket_symbols:
            if symbol in self.historical_data and self.target in self.historical_data:
                x, y = self.historical_data[self.target], self.historical_data[symbol]
                if len(x) == len(y):
                    corr = np.corrcoef(x, y)[0, 1]
                    if not np.isnan(corr):
                        correlations.append(corr)
                        valid.append(symbol)
                        logger.info(f"Correlation BTC/{symbol}: {corr:.4f}")
        self.basket_symbols = valid
        if not correlations:
            if not self.basket_symbols:
                logger.error("No valid symbols for basket weights.")
                return
            self.basket_weights = np.ones(len(self.basket_symbols)) / len(self.basket_symbols)
            return
        abs_corr = np.abs(correlations)
        self.basket_weights = abs_corr / np.sum(abs_corr)
        logger.info("Calculated basket weights:")
        for s, w, c in zip(self.basket_symbols, self.basket_weights, correlations):
            logger.info(f"  {s}: {w:.3f} (corr={c:.3f})")

    def get_current_prices(self):
        prices = {}
        try:
            symbols = [self.target] + self.basket_symbols
            tickers = self.exchange.fetch_tickers(symbols)
            for s in symbols:
                if s in tickers and tickers[s].get("last") is not None:
                    prices[s] = tickers[s]["last"]
            if len(prices) != len(symbols):
                logger.warning("Some prices are missing.")
                return None
            return prices
        except Exception as e:
            logger.warning(f"Error fetching tickers: {e}")
            return None

    def calculate_basket_price(self, prices):
        return sum(self.basket_weights[i] * prices[s] for i, s in enumerate(self.basket_symbols) if s in prices)

    def calculate_spread_series(self):
        min_len = min(len(self.historical_data[s]) for s in [self.target]+self.basket_symbols if s in self.historical_data)
        if min_len < 10:
            logger.warning("Insufficient historical data.")
            return None
        target = np.array(self.historical_data[self.target][-min_len:])
        basket = np.zeros(min_len)
        for i, s in enumerate(self.basket_symbols):
            basket += self.basket_weights[i] * np.array(self.historical_data[s][-min_len:])
        return target / basket

    def calculate_zscore(self, current_prices):
        if not all(s in current_prices for s in [self.target]+self.basket_symbols):
            return None, None, None
        spread_now = current_prices[self.target] / self.calculate_basket_price(current_prices)
        spread_hist = self.calculate_spread_series()
        if spread_hist is None:
            return None, None, None
        mean, std = np.mean(spread_hist), np.std(spread_hist)
        if std < 1e-10:
            return None, None, None
        z = (spread_now - mean) / std
        return z, spread_now, (mean, std)

    def trading_signal(self, z):
        if z is None: return "NO DATA"
        if z > 2.0: return "SHORT BTC / LONG BASKET"
        if z < -2.0: return "LONG BTC / SHORT BASKET"
        if abs(z) < 0.5: return "EXIT POSITION"
        return "HOLD"

    def run(self, interval_minutes=5):
        logger.info("Starting OKX basket monitor...")
        if not self.fetch_historical_data():
            logger.error("Failed to fetch historical data.")
            return
        self.calculate_basket_weights()
        if not self.basket_symbols:
            logger.error("No valid symbols for monitoring.")
            return
        logger.info(f"Monitoring symbols: {self.basket_symbols}")

        while True:
            try:
                prices = self.get_current_prices()
                if not prices:
                    time.sleep(60)
                    continue

                z, spread, stats = self.calculate_zscore(prices)
                if z is not None:
                    mean, std = stats
                    signal = self.trading_signal(z)
                    report = f"""
=== OKX FUTURES BASKET MONITOR ===
Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M')} UTC
BTC-USDT: {prices[self.target]:.2f}
Basket Price: {self.calculate_basket_price(prices):.2f}
Spread: {spread:.6f}
Mean: {mean:.6f} ± {std:.6f}
Z-Score: {z:.4f}
Signal: {signal}
Status: {"NORMAL" if abs(z)<0.5 else "WATCH" if abs(z)<2 else "SIGNAL"}
"""
                    print(report)

                    self.notify({
                        "time": datetime.utcnow(),
                        "target_price": prices[self.target],
                        "basket_price": self.calculate_basket_price(prices),
                        "spread": spread,
                        "mean": mean,
                        "std": std,
                        "z": z,
                        "signal": signal,
                        "basket_symbols": self.basket_symbols,
                        "basket_weights": self.basket_weights
                    })
                else:
                    logger.warning("Z-score unavailable.")
                time.sleep(interval_minutes*60)
            except KeyboardInterrupt:
                logger.info("Monitoring stopped by user.")
                break
            except Exception as e:
                logger.warning(f"Error in loop: {e}")
                time.sleep(60)


def main():
    monitor = OKXBasketMonitor()

    console_observer = ConsoleObserver()
    monitor.attach(console_observer)

    telegram_observer = TelegramObserver(
        token="8436652130:AAF6On0GJtRHfMZyqD3mpM57eXZfWofJeng",
        chat_id="317217451"
    )
    monitor.attach(telegram_observer)

    # --- Тестовое сообщение при старте ---
    try:
        telegram_observer.update({
            "time": None,
            "target_price": 0,
            "basket_price": 0,
            "spread": 0,
            "mean": 0,
            "std": 0,
            "z": 0,
            "signal": "✅ Test message: TelegramObserver работает!"
        })
        print("✅ Test message queued for Telegram")
    except Exception as e:
        print("❌ Failed to queue test message:", e)
    # -----------------------------------

    monitor.run(interval_minutes=5)


if __name__ == "__main__":
    main()


===== observer.py =====


class Observer:
    """Observer interface."""
    def update(self, data):
        raise NotImplementedError("Observer subclasses must implement 'update' method.")


class Subject:
    """Base class for observable objects."""
    def __init__(self):
        self._observers = []

    def attach(self, observer: Observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def detach(self, observer: Observer):
        if observer in self._observers:
            self._observers.remove(observer)

    def notify(self, data=None):
        for observer in self._observers:
            observer.update(data)


===== telegram_observer.py =====


from observer import Observer
from telegram import Bot
from datetime import datetime
import asyncio

class TelegramObserver(Observer):
    def __init__(self, token: str, chat_id: str):
        self.bot = Bot(token=token)
        self.chat_id = chat_id

    def update(self, data):
        msg = (
            f"[{datetime.utcnow().strftime('%Y-%m-%d %H:%M')}] Basket Monitor Update\n"
            f"Signal: {data['signal']}\n"
            f"Z-score: {data['z']:.4f}\n"
            f"Spread: {data['spread']:.6f}\n"
            f"Basket Price: {data['basket_price']:.2f}\n"
            f"Target Price: {data['target_price']:.2f}"
        )
        # Отправляем сообщение синхронно через asyncio.run
        try:
            asyncio.run(self.bot.send_message(chat_id=self.chat_id, text=msg))
            print(f"✅ Telegram message sent: {msg[:50]}...")
        except Exception as e:
            print(f"❌ Failed to send Telegram message: {e}")


===== test_bot.py =====


import asyncio
from telegram import Bot

async def main():
    bot = Bot(token="8436652130:AAF6On0GJtRHfMZyqD3mpM57eXZfWofJeng")
    me = await bot.get_me()
    print(me)

asyncio.run(main())


===== test_trader.py =====


# test_trader.py

from monitor import OKXBasketMonitor
from trader import OKXBasketTrader
from console_observer import ConsoleObserver

def main():
    # Создаем монитор
    monitor = OKXBasketMonitor()

    # Подключаем ConsoleObserver для логов
    console_observer = ConsoleObserver()
    monitor.attach(console_observer)

    # Подключаем трейдер в режиме paper trading
    trader = OKXBasketTrader(paper_trading=True, max_exposure=1000)
    monitor.attach(trader)

    print("✅ Starting monitor + trader in PAPER TRADING mode...")
    # Запускаем монитор (он будет уведомлять трейдера)
    monitor.run(interval_minutes=1)  # маленький интервал для теста

if __name__ == "__main__":
    main()


===== trader.py =====


# trader.py

from observer import Observer
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class OKXBasketTrader(Observer):
    def __init__(self, paper_trading=True, max_exposure=1000):
        """
        paper_trading: True — не ставит реальные ордера, только выводит в консоль.
        max_exposure: максимальная сумма на одну позицию.
        """
        self.paper_trading = paper_trading
        self.max_exposure = max_exposure
        self.current_positions = {}  # словарь вида {'BTC/USDT': size, 'ETH/USDT': size}

    def update(self, data):
        """
        Метод Observer: вызывается при каждом новом сигнале от монитора.
        """
        signal = data.get("signal")
        if signal:
            self.execute_signal(signal, data)

    def execute_signal(self, signal, data):
        """
        Пока просто выводит, что будет сделано.
        На следующем шаге сюда будем добавлять реальные ордера.
        """
        if self.paper_trading:
            logger.info(f"[PAPER TRADING] Signal received: {signal}")
            logger.info(f"[PAPER TRADING] Data: {data}")
        else:
            logger.info(f"[REAL TRADING] Would execute: {signal}")
