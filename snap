

===== backtester.py =====


import pandas as pd

def BacktestPortfolio(returns_list):
    # returns_list: —Å–ø–∏—Å–æ–∫ Series TotalReturn –¥–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã
    df = pd.concat(returns_list, axis=1)
    portfolio_return = df.mean(axis=1)
    return portfolio_return


===== main.py =====


from pairs_core import BacktestPair
from backtester import BacktestPortfolio
import ccxt
from itertools import combinations

def get_top10_symbols():
    exchange = ccxt.okx()
    exchange.load_markets()
    # —Ñ–∏–ª—å—Ç—Ä–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Å–ø–æ—Ç –ø–∞—Ä—ã USDT
    symbols = [s for s in exchange.symbols if '/USDT' in s]
    # —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –æ–±—ä—ë–º—É 24h
    symbols = sorted(symbols, key=lambda x: exchange.fetch_ticker(x)['quoteVolume'], reverse=True)
    return symbols[:10]

def main():
    top10 = get_top10_symbols()
    pairs = list(combinations(top10, 2))
    
    print("Top-10 –º–æ–Ω–µ—Ç:", top10)
    print("–í—Å–µ–≥–æ –ø–∞—Ä:", len(pairs))
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –±—ç–∫—Ç–µ—Å—Ç
    results = []
    for base, quote in pairs:
        print(f"–ë—ç–∫—Ç–µ—Å—Ç –¥–ª—è –ø–∞—Ä—ã {base}/{quote}")
        # fetch OHLCV –¥–ª—è –ø–∞—Ä—ã
        # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –∑–∞–≥—Ä—É–∑–∫–∏ CSV –∏–ª–∏ fetch_ohlcv
        # df = load_data_from_csv_or_api(base, quote)
        # df_backtest = BacktestPair(df)
        # results.append(df_backtest['TotalReturn'])
    
    # –°–±–æ—Ä–∫–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—è
    # portfolio_returns = BacktestPortfolio(results)
    # print(portfolio_returns)

if __name__ == "__main__":
    main()


===== pairs_core.py =====


import pandas as pd
import numpy as np
import statsmodels.api as sm

def calculate_spread(df):
    # df: –∫–æ–ª–æ–Ω–∫–∏ ['A', 'B']
    X = sm.add_constant(df['B'])
    model = sm.OLS(df['A'], X).fit()
    beta = model.params[1]
    df['spread'] = df['A'] - beta * df['B']
    return df, beta

def generate_signals(df, window=35, entry_z=1, exit_z=0.5):
    df['mean'] = df['spread'].rolling(window).mean()
    df['std'] = df['spread'].rolling(window).std()
    df['zscore'] = (df['spread'] - df['mean']) / df['std']
    
    df['signal'] = 0
    df.loc[df['zscore'] > entry_z, 'signal'] = -1  # short spread
    df.loc[df['zscore'] < -entry_z, 'signal'] = 1  # long spread
    df.loc[df['zscore'].abs() < exit_z, 'signal'] = 0  # close
    
    return df

def BacktestPair(df, window=35):
    df, beta = calculate_spread(df)
    df = generate_signals(df, window)
    # –∑–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ä–∞—Å—á—ë—Ç –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∏–≥–Ω–∞–ª–æ–≤
    df['TotalReturn'] = df['signal'].shift(1) * (df['spread'].diff())
    return df


===== telegram_bot.py =====


# telegram_bot.py - –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π Telegram –±–æ—Ç —Å –∫–Ω–æ–ø–∫–∞–º–∏
import requests
import json
import logging
from typing import Optional, List, Dict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TelegramBot:
    def __init__(self, token: str, chat_id: str):
        self.token = token
        self.chat_id = chat_id
        self.base_url = f"https://api.telegram.org/bot{token}"
        
    def safe_format_number(self, value, precision=2):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–µ–ª"""
        try:
            if value is None:
                return "N/A"
            return f"{float(value):.{precision}f}"
        except (ValueError, TypeError):
            return str(value)
        
    def send_message(self, text: str, buttons: Optional[List] = None) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–Ω–æ–ø–∫–∞–º–∏"""
        payload = {
            'chat_id': self.chat_id,
            'text': text,
            'parse_mode': 'HTML'
        }
        
        if buttons:
            payload['reply_markup'] = json.dumps({'inline_keyboard': buttons})
            
        try:
            response = requests.post(f"{self.base_url}/sendMessage", json=payload, timeout=10)
            return response.status_code == 200
        except Exception as e:
            logger.error(f"Failed to send message: {e}")
            return False
    
    def send_signal_alert(self, pair_data: Dict) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –¥–µ–π—Å—Ç–≤–∏–π"""
        try:
            pair_name = pair_data.get('pair_name', 'UNKNOWN')
            signal = pair_data.get('signal', 'NO_SIGNAL')
            z_score = pair_data.get('z_score')
            adf_passed = pair_data.get('adf_passed', False)
            price_a = pair_data.get('price_a')
            price_b = pair_data.get('price_b')
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
            z_display = self.safe_format_number(z_score, 2)
            price_a_display = self.safe_format_number(price_a, 2)
            price_b_display = self.safe_format_number(price_b, 2)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª
            formatted_signal = signal
            if "SHORT_" in signal and "LONG_" in signal:
                parts = signal.split('_')
                if len(parts) >= 4:
                    formatted_signal = f"SHORT {parts[1]} / LONG {parts[3]}"
            
            message = (
                f"üéØ <b>TRADING SIGNAL</b>\n"
                f"Pair: <b>{pair_name}</b>\n"
                f"Signal: <b>{formatted_signal}</b>\n"
                f"Z-score: {z_display}\n"
                f"ADF: {'‚úÖ PASSED' if adf_passed else '‚ùå FAILED'}\n"
                f"Prices: {price_a_display} | {price_b_display}"
            )
            
            # –ö–Ω–æ–ø–∫–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
            buttons = None
            if signal not in ['HOLD', 'NO_DATA', 'EXIT_POSITION']:
                buttons = [
                    [
                        {'text': 'üìà OPEN', 'callback_data': f'OPEN:{signal}:{pair_name}'},
                        {'text': '‚ùå CLOSE', 'callback_data': f'CLOSE:{signal}:{pair_name}'}
                    ]
                ]
            elif signal == 'EXIT_POSITION':
                buttons = [
                    [{'text': 'üî¥ CLOSE POSITION', 'callback_data': f'CLOSE:{signal}:{pair_name}'}]
                ]
                
            return self.send_message(message, buttons)
            
        except Exception as e:
            logger.error(f"Error in send_signal_alert: {e}")
            return self.send_message(f"‚ùå Error generating signal: {str(e)}")
    
    def send_status_report(self, report_data: Dict, open_positions: List = None) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ç–∞—Ç—É—Å –æ—Ç—á–µ—Ç–∞"""
        try:
            if not report_data:
                return self.send_message("‚ùå No report data available")
                
            open_positions = open_positions or []
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            total_pairs = report_data.get('total_pairs', 0)
            active_pairs = report_data.get('active_pairs', 0)
            trading_signals = report_data.get('trading_signals', 0)
            
            message = (
                f"üìä <b>PAIRS MONITORING STATUS</b>\n"
                f"Total Pairs: {total_pairs}\n"
                f"Active Pairs: {active_pairs}\n"
                f"Trading Signals: {trading_signals}\n"
                f"Open Positions: {len(open_positions)}"
            )
            
            # –î–µ—Ç–∞–ª–∏ –ø–æ –æ—Ç–∫—Ä—ã—Ç—ã–º –ø–æ–∑–∏—Ü–∏—è–º
            if open_positions:
                message += "\n\nüéØ <b>OPEN POSITIONS:</b>\n"
                for pos in open_positions[:5]:  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
                    pair_name = pos.get('pair', 'N/A')
                    signal = pos.get('signal', 'N/A')
                    message += f"‚Ä¢ {pair_name} - {signal}\n"
            
            # –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            buttons = [
                [
                    {'text': 'üìà Summary', 'callback_data': 'SUMMARY'},
                    {'text': 'üõë Close All', 'callback_data': 'CLOSE_ALL'}
                ],
                [
                    {'text': 'üîÑ Refresh', 'callback_data': 'REFRESH'}
                ]
            ]
            
            return self.send_message(message, buttons)
            
        except Exception as e:
            logger.error(f"Error in send_status_report: {e}")
            return self.send_message(f"‚ùå Error generating status report: {str(e)}")
    
    def handle_callback(self, callback_data: str, pair_analyzer, positions_manager) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ callback –æ—Ç –∫–Ω–æ–ø–æ–∫"""
        try:
            if callback_data == 'SUMMARY':
                report = pair_analyzer.get_analysis_report()
                return self.send_status_report(report, positions_manager.get_open_positions())
                
            elif callback_data == 'CLOSE_ALL':
                closed_count = positions_manager.close_all_positions()
                return self.send_message(f"‚úÖ Closed {closed_count} positions")
                
            elif callback_data == 'REFRESH':
                report = pair_analyzer.get_analysis_report()
                return self.send_status_report(report, positions_manager.get_open_positions())
                
            elif callback_data.startswith(('OPEN:', 'CLOSE:')):
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥
                try:
                    action, signal, pair_name = callback_data.split(':', 2)
                    if action == 'OPEN':
                        success = positions_manager.open_position(signal, pair_name)
                        msg = f"‚úÖ Opened position: {pair_name}" if success else f"‚ùå Failed to open: {pair_name}"
                    else:
                        success = positions_manager.close_position(signal, pair_name)
                        msg = f"‚úÖ Closed position: {pair_name}" if success else f"‚ùå Failed to close: {pair_name}"
                    return self.send_message(msg)
                except ValueError:
                    return self.send_message("‚ùå Invalid callback format")
                
            return self.send_message(f"‚ùå Unknown command: {callback_data}")
            
        except Exception as e:
            logger.error(f"Error handling callback: {e}")
            return self.send_message(f"‚ùå Error: {str(e)}")


class SimplePositionsManager:
    """–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–∑–∏—Ü–∏–π (–±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞)"""
    def __init__(self):
        self.open_positions = []
        
    def open_position(self, signal: str, pair_name: str) -> bool:
        """–û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ (–¥–µ–º–æ)"""
        try:
            position = {
                'pair': pair_name,
                'signal': signal,
                'size': 1000,
                'entry_time': '2024-10-24'
            }
            self.open_positions.append(position)
            logger.info(f"Opened position: {pair_name} - {signal}")
            return True
        except Exception as e:
            logger.error(f"Error opening position: {e}")
            return False
        
    def close_position(self, signal: str, pair_name: str) -> bool:
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ (–¥–µ–º–æ)"""
        try:
            initial_count = len(self.open_positions)
            self.open_positions = [p for p in self.open_positions if p['pair'] != pair_name]
            closed = initial_count - len(self.open_positions)
            logger.info(f"Closed position: {pair_name} ({closed} positions)")
            return closed > 0
        except Exception as e:
            logger.error(f"Error closing position: {e}")
            return False
        
    def close_all_positions(self) -> int:
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –ø–æ–∑–∏—Ü–∏–π"""
        try:
            count = len(self.open_positions)
            self.open_positions.clear()
            logger.info(f"Closed all {count} positions")
            return count
        except Exception as e:
            logger.error(f"Error closing all positions: {e}")
            return 0
        
    def get_open_positions(self) -> List:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π"""
        return self.open_positions.copy()
