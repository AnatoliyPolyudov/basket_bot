

===== callback_handler.py =====


# callback_handler.py
def handle_callback(callback_data, trader):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –∫–Ω–æ–ø–æ–∫ Telegram.
    callback_data: 'OPEN:LONG BTC / SHORT BASKET' –∏–ª–∏ 'CLOSE:LONG BTC / SHORT BASKET'
    """
    try:
        action, signal = callback_data.split(":", 1)
        if trader is None:
            print("‚ùå Trader not provided for callback")
            return

        if action == "OPEN":
            trader.open_position(signal)
        elif action == "CLOSE":
            trader.close_position(signal)
        else:
            print(f"‚ùå Unknown callback action: {action}")
    except Exception as e:
        print(f"‚ùå Callback handler error: {e}")


===== console_observer.py =====


from observer import Observer
from datetime import datetime

class ConsoleObserver(Observer):
    def update(self, data):
        basket_symbols = data.get('basket_symbols', [])
        symbols_text = "\n".join(basket_symbols) if basket_symbols else "‚Äî"

        print(f"[{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}] Basket Monitor Update")
        print(f"Signal: {data.get('signal')}")
        print(f"Z-score: {data.get('z', 0):.4f}")
        print(f"Spread: {data.get('spread', 0):.6f}")
        print(f"Basket Price: {data.get('basket_price', 0):.2f}")
        print(f"Target Price: {data.get('target_price', 0):.2f}")
        print(f"Current pairs:\n{symbols_text}")
        print("-" * 50)


===== monitor.py =====


import ccxt
import pandas as pd
import numpy as np
import time
import logging
from datetime import datetime, timedelta
from observer import Subject
from console_observer import ConsoleObserver
from trader import OKXBasketTrader
from telegram_observer import TelegramObserver
from callback_handler import handle_callback
import threading
import requests

logging.basicConfig(level=logging.INFO, format="%(message)s")
logger = logging.getLogger(__name__)

# –°–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–π –ª–æ–≥–≥–µ—Ä –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –≤—ã–≤–æ–¥–∞
console_logger = logging.StreamHandler()
console_logger.setLevel(logging.INFO)
formatter = logging.Formatter('%(message)s')
console_logger.setFormatter(formatter)

pretty_logger = logging.getLogger('pretty')
pretty_logger.setLevel(logging.INFO)
pretty_logger.addHandler(console_logger)
pretty_logger.propagate = False

class OKXBasketMonitor(Subject):
    def __init__(self):
        super().__init__()
        self.exchange = ccxt.okx({
            "enableRateLimit": True,
            "options": {"defaultType": "swap"},
            "sandbox": False
        })
        self.target = "ETH/USDT:USDT"
        # –ú–µ–º-–∫–æ—Ä–∑–∏–Ω–∞ –≤–º–µ—Å—Ç–æ –æ–±—ã—á–Ω—ã—Ö –∞–ª—å—Ç–æ–≤
        self.basket_symbols = ["DOGE/USDT:USDT", "SHIB/USDT:USDT", "PEPE/USDT:USDT"]
        self.basket_weights = []
        self.historical_data = {}
        self.lookback_days = 30

    def fetch_historical_data(self):
        logger.info("üìä Fetching historical data from OKX...")
        for symbol in [self.target] + self.basket_symbols:
            try:
                since = self.exchange.parse8601(
                    (datetime.utcnow() - pd.Timedelta(days=self.lookback_days)).isoformat()
                )
                ohlcv = self.exchange.fetch_ohlcv(symbol, "1d", since=since, limit=30)
                if not ohlcv:
                    logger.warning(f"‚ö†Ô∏è No data for {symbol}")
                    continue
                self.historical_data[symbol] = [c[4] for c in ohlcv]
                logger.info(f"‚úÖ Loaded {len(self.historical_data[symbol])} days for {symbol}")
            except Exception as e:
                logger.warning(f"‚ùå Error loading {symbol}: {e}")

        valid = [s for s in [self.target]+self.basket_symbols if s in self.historical_data and len(self.historical_data[s])>=10]
        if len(valid) < 3:
            logger.error("‚ùå Not enough valid symbols for analysis.")
            return False
        return True

    def calculate_basket_weights(self):
        correlations, valid = [], []
        
        pretty_logger.info("üîç " + "="*50)
        pretty_logger.info("üîç –ê–ù–ê–õ–ò–ó –ö–û–†–†–ï–õ–Ø–¶–ò–ô –° BTC")
        pretty_logger.info("üîç " + "="*50)
        
        for symbol in self.basket_symbols:
            if symbol in self.historical_data and self.target in self.historical_data:
                x, y = self.historical_data[self.target], self.historical_data[symbol]
                if len(x) == len(y):
                    corr = np.corrcoef(x, y)[0, 1]
                    if not np.isnan(corr):
                        correlations.append(corr)
                        valid.append(symbol)
                        
                        # –ö–†–ê–°–ò–í–´–ô –í–´–í–û–î –ö–û–†–†–ï–õ–Ø–¶–ò–ô
                        asset_name = symbol.split('/')[0]
                        corr_percent = abs(corr) * 100
                        
                        if corr > 0.8:
                            emoji, quality = "üü¢", "–û–¢–õ–ò–ß–ù–ê–Ø"
                        elif corr > 0.6:
                            emoji, quality = "üü°", "–•–û–†–û–®–ê–Ø" 
                        elif corr > 0.4:
                            emoji, quality = "üü†", "–°–†–ï–î–ù–Ø–Ø"
                        elif corr > 0.2:
                            emoji, quality = "üî¥", "–°–õ–ê–ë–ê–Ø"
                        else:
                            emoji, quality = "üí§", "–û–¢–°–£–¢–°–¢–í–£–ï–¢"
                        
                        direction = "–ø—Ä—è–º–∞—è" if corr > 0 else "–æ–±—Ä–∞—Ç–Ω–∞—è"
                        pretty_logger.info(f"{emoji} {asset_name:6} | {corr:7.3f} | {corr_percent:5.1f}% | {quality:10} | {direction}")
        
        pretty_logger.info("üîç " + "="*50)
        
        self.basket_symbols = valid
        if not correlations:
            if not self.basket_symbols:
                logger.error("‚ùå No valid symbols for basket weights.")
                return
            self.basket_weights = np.ones(len(self.basket_symbols)) / len(self.basket_symbols)
            return
        
        abs_corr = np.abs(correlations)
        self.basket_weights = abs_corr / np.sum(abs_corr)
        
        pretty_logger.info("üéØ " + "="*50)
        pretty_logger.info("üéØ –ò–¢–û–ì–û–í–ê–Ø –ö–û–†–ó–ò–ù–ê –° –í–ï–°–ê–ú–ò")
        pretty_logger.info("üéØ " + "="*50)
        
        total_corr = 0
        for s, w, c in zip(self.basket_symbols, self.basket_weights, correlations):
            asset_name = s.split('/')[0]
            total_corr += abs(c)
            pretty_logger.info(f"üìä {asset_name:6} | –í–µ—Å: {w:6.3f} | –ö–æ—Ä—Ä: {c:6.3f}")
        
        avg_correlation = total_corr / len(correlations)
        pretty_logger.info(f"üìà –°—Ä–µ–¥–Ω—è—è –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è: {avg_correlation:.3f}")
        pretty_logger.info("üéØ " + "="*50)

    def get_current_prices(self):
        prices = {}
        try:
            symbols = [self.target] + self.basket_symbols
            tickers = self.exchange.fetch_tickers(symbols)
            for s in symbols:
                if s in tickers and tickers[s].get("last") is not None:
                    prices[s] = tickers[s]["last"]
            if len(prices) != len(symbols):
                logger.warning("‚ö†Ô∏è Some prices are missing.")
                return None
            return prices
        except Exception as e:
            logger.warning(f"‚ùå Error fetching tickers: {e}")
            return None

    def calculate_basket_price(self, prices):
        return sum(self.basket_weights[i] * prices[s] for i, s in enumerate(self.basket_symbols) if s in prices)

    def calculate_spread_series(self):
        min_len = min(len(self.historical_data[s]) for s in [self.target]+self.basket_symbols if s in self.historical_data)
        if min_len < 10:
            logger.warning("‚ö†Ô∏è Insufficient historical data.")
            return None
        target = np.array(self.historical_data[self.target][-min_len:])
        basket = np.zeros(min_len)
        for i, s in enumerate(self.basket_symbols):
            basket += self.basket_weights[i] * np.array(self.historical_data[s][-min_len:])
        return target / basket

    def calculate_zscore(self, current_prices):
        if not all(s in current_prices for s in [self.target]+self.basket_symbols):
            return None, None, None
        spread_now = current_prices[self.target] / self.calculate_basket_price(current_prices)
        spread_hist = self.calculate_spread_series()
        if spread_hist is None:
            return None, None, None
        mean, std = np.mean(spread_hist), np.std(spread_hist)
        if std < 1e-10:
            return None, None, None
        z = (spread_now - mean) / std
        return z, spread_now, (mean, std)

    def trading_signal(self, z):
        if z is None: return "NO DATA"
        if z > 2.0: return "SHORT BTC / LONG BASKET"
        if z < -2.0: return "LONG BTC / SHORT BASKET"
        if abs(z) < 0.5: return "EXIT POSITION"
        return "HOLD"

    def run(self, interval_minutes=1):
        logger.info("üöÄ Starting OKX basket monitor...")
        if not self.fetch_historical_data():
            logger.error("‚ùå Failed to fetch historical data.")
            return
        self.calculate_basket_weights()
        if not self.basket_symbols:
            logger.error("‚ùå No valid symbols for monitoring.")
            return
        logger.info(f"üìä Monitoring symbols: {self.basket_symbols}")

        last_telegram_time = datetime.utcnow() - timedelta(minutes=10)

        # --- –ø–µ—Ä–≤–æ–µ –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ---
        prices = self.get_current_prices()
        if prices:
            z, spread, stats = self.calculate_zscore(prices)
            mean, std = stats if stats else (0, 0)
            signal = self.trading_signal(z)
            report_data = {
                "time": datetime.utcnow(),
                "target_price": prices.get(self.target, 0),
                "basket_price": self.calculate_basket_price(prices),
                "spread": spread if spread else 0,
                "mean": mean,
                "std": std,
                "z": z if z else 0,
                "signal": signal,
                "basket_symbols": self.basket_symbols,
                "basket_weights": self.basket_weights
            }
            self.notify(report_data)
            last_telegram_time = datetime.utcnow()

        while True:
            try:
                prices = self.get_current_prices()
                if not prices:
                    time.sleep(60)
                    continue

                z, spread, stats = self.calculate_zscore(prices)
                if z is not None:
                    mean, std = stats
                    signal = self.trading_signal(z)

                    report_data = {
                        "time": datetime.utcnow(),
                        "target_price": prices[self.target],
                        "basket_price": self.calculate_basket_price(prices),
                        "spread": spread,
                        "mean": mean,
                        "std": std,
                        "z": z,
                        "signal": signal,
                        "basket_symbols": self.basket_symbols,
                        "basket_weights": self.basket_weights
                    }

                    # –ö—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥ Z-score –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
                    current_time = datetime.utcnow().strftime('%H:%M:%S')
                    if abs(z) < 1.0:
                        z_color = "üü¢"
                    elif abs(z) < 2.0:
                        z_color = "üü°"
                    elif abs(z) < 3.0:
                        z_color = "üü†"
                    else:
                        z_color = "üî¥"
                    
                    pretty_logger.info(f"{z_color} [{current_time}] Z-score: {z:6.2f} | –°–∏–≥–Ω–∞–ª: {signal}")

                    if datetime.utcnow() - last_telegram_time >= timedelta(minutes=10):
                        self.notify(report_data)
                        last_telegram_time = datetime.utcnow()
                else:
                    current_time = datetime.utcnow().strftime('%H:%M:%S')
                    pretty_logger.info(f"‚ö™ [{current_time}] Z-score: –ù–ï–¢ –î–ê–ù–ù–´–•")

                time.sleep(interval_minutes*60)
            except KeyboardInterrupt:
                logger.info("üõë Monitoring stopped by user.")
                break
            except Exception as e:
                logger.warning(f"‚ùå Error in loop: {e}")
                time.sleep(60)


def telegram_polling(trader):
    TELEGRAM_BOT_TOKEN = "8436652130:AAF6On0GJtRHfMZyqD3mpM57eXZfWofJeng"
    offset = None
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"

    while True:
        try:
            params = {'timeout': 30, 'offset': offset}
            response = requests.get(url, params=params, timeout=35)
            updates = response.json().get("result", [])
            for update in updates:
                if "callback_query" in update:
                    data = update["callback_query"]["data"]
                    handle_callback(data, trader)
                offset = (update["update_id"] + 1)
            time.sleep(1)
        except Exception as e:
            print("‚ùå Telegram polling error:", e)
            time.sleep(5)


def main():
    monitor = OKXBasketMonitor()

    monitor.attach(ConsoleObserver())

    trader = OKXBasketTrader(paper_trading=True, max_exposure=1000)
    monitor.attach(trader)

    telegram_observer = TelegramObserver(trader=trader)
    monitor.attach(telegram_observer)

    polling_thread = threading.Thread(target=telegram_polling, args=(trader,), daemon=True)
    polling_thread.start()

    monitor.run(interval_minutes=1)


if __name__ == "__main__":
    main()

===== observer.py =====


class Observer:
    """Observer interface."""
    def update(self, data):
        raise NotImplementedError("Observer subclasses must implement 'update' method.")


class Subject:
    """Base class for observable objects."""
    def __init__(self):
        self._observers = []

    def attach(self, observer: Observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def detach(self, observer: Observer):
        if observer in self._observers:
            self._observers.remove(observer)

    def notify(self, data=None):
        for observer in self._observers:
            observer.update(data)


===== telegram_observer.py =====


from observer import Observer
import json
import requests
from callback_handler import handle_callback

TELEGRAM_BOT_TOKEN = "8436652130:AAF6On0GJtRHfMZyqD3mpM57eXZfWofJeng"
TELEGRAM_CHAT_ID = 317217451

class TelegramObserver(Observer):
    def __init__(self, trader=None):
        self.token = TELEGRAM_BOT_TOKEN
        self.chat_id = TELEGRAM_CHAT_ID
        self.trader = trader

    def send_message(self, text, buttons=None):
        url = f"https://api.telegram.org/bot{self.token}/sendMessage"
        payload = {
            'chat_id': self.chat_id,
            'text': text,
            'parse_mode': 'HTML'
        }
        if buttons:
            payload['reply_markup'] = json.dumps({'inline_keyboard': buttons})
        try:
            requests.post(url, data=payload, timeout=10)
            print("‚úÖ Telegram message sent")
        except Exception as e:
            print("‚ùå Telegram send failed:", e)

    def update(self, data):
        basket_symbols = data.get('basket_symbols', [])
        symbols_text = "\n".join(basket_symbols) if basket_symbols else "‚Äî"

        # –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–æ–±–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        z_score = round(data.get('z', 0), 2)
        spread = round(data.get('spread', 0), 3)
        basket_price = round(data.get('basket_price', 0), 2)
        target_price = round(data.get('target_price', 0), 2)

        msg = (
            f"Z-score: {z_score}\n"
            f"Spread: {spread}\n"
            f"Basket Price: {basket_price}\n"
            f"Target Price: {target_price}\n"
            f"Current pairs:\n{symbols_text}"
        )

        buttons = None
        signal = data.get('signal', "")
        if signal and signal != "NO DATA":
            buttons = [
                [
                    {'text': 'Open', 'callback_data': f'OPEN:{signal}'},
                    {'text': 'Close', 'callback_data': f'CLOSE:{signal}'}
                ]
            ]

        self.send_message(msg, buttons)


===== trader.py =====


from observer import Observer
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class OKXBasketTrader(Observer):
    def __init__(self, paper_trading=True, max_exposure=1000):
        """
        paper_trading: True ‚Äî –Ω–µ —Å—Ç–∞–≤–∏—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞, —Ç–æ–ª—å–∫–æ –≤—ã–≤–æ–¥–∏—Ç –≤ –∫–æ–Ω—Å–æ–ª—å.
        max_exposure: –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –Ω–∞ –æ–¥–Ω—É –ø–æ–∑–∏—Ü–∏—é.
        """
        self.paper_trading = paper_trading
        self.max_exposure = max_exposure
        self.current_positions = {}  # —Å–ª–æ–≤–∞—Ä—å –≤–∏–¥–∞ {'BTC/USDT': size, 'ETH/USDT': size}

    def update(self, data):
        """
        –ú–µ—Ç–æ–¥ Observer: –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –∫–∞–∂–¥–æ–º –Ω–æ–≤–æ–º —Å–∏–≥–Ω–∞–ª–µ –æ—Ç –º–æ–Ω–∏—Ç–æ—Ä–∞.
        """
        signal = data.get("signal")
        if signal:
            self.execute_signal(signal, data)

    def execute_signal(self, signal, data):
        """
        –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –≤—ã–≤–æ–¥–∏—Ç, —á—Ç–æ –±—É–¥–µ—Ç —Å–¥–µ–ª–∞–Ω–æ.
        """
        if self.paper_trading:
            logger.info(f"[PAPER TRADING] Signal received: {signal}")
            logger.info(f"[PAPER TRADING] Data: {data}")
        else:
            logger.info(f"[REAL TRADING] Would execute: {signal}")

    # --- –ú–µ—Ç–æ–¥—ã –¥–ª—è –∫–Ω–æ–ø–æ–∫ ---
    def open_position(self, symbol: str, size=None):
        if size is None:
            size = self.max_exposure
        self.current_positions[symbol] = size
        logger.info(f"[PAPER TRADING] Opened position {symbol} with size {size}")

    def close_position(self, symbol: str):
        if symbol in self.current_positions:
            del self.current_positions[symbol]
            logger.info(f"[PAPER TRADING] Closed position {symbol}")
        else:
            logger.info(f"[PAPER TRADING] No open position to close for {symbol}")
