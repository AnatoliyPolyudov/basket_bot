

===== backtester.py =====


import pandas as pd

def BacktestPortfolio(returns_list):
    # returns_list: —Å–ø–∏—Å–æ–∫ Series TotalReturn –¥–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã
    df = pd.concat(returns_list, axis=1)
    portfolio_return = df.mean(axis=1)
    return portfolio_return


===== main.py =====


import logging
import time
import pandas as pd
from pairs_core import BacktestPair, BacktestPortfolio, GenerateReport_xts
from telegram_bot import start_telegram_bot  # –µ—Å–ª–∏ —É —Ç–µ–±—è –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler("basket-bot.log"),  # –∑–∞–ø–∏—Å—å –≤ —Ñ–∞–π–ª
        logging.StreamHandler()                 # –≤—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å
    ]
)

def main():
    logging.info("Basket bot started")

    # –ü—Ä–∏–º–µ—Ä: –∑–∞–ø—É—Å–∫ –±—ç–∫—Ç–µ—Å—Ç–∞ –¥–ª—è –æ–¥–Ω–æ–π –ø–∞—Ä—ã
    try:
        logging.info("Loading pair data from CSV...")
        data = pd.read_csv('pairs_sample.csv')  # —É–∫–∞–∂–∏ —Ä–µ–∞–ª—å–Ω—ã–π CSV
        logging.info("Running backtest for single pair...")
        result = BacktestPair(data, mean=35, generateReport=True)
        logging.info("Single pair backtest done")

        # –ü—Ä–∏–º–µ—Ä: –∑–∞–ø—É—Å–∫ –ø–æ—Ä—Ç—Ñ–µ–ª—è
        logging.info("Running portfolio backtest...")
        names = ['pair1.csv', 'pair2.csv']  # —Å–ø–∏—Å–æ–∫ —Ä–µ–∞–ª—å–Ω—ã—Ö CSV —Ñ–∞–π–ª–æ–≤
        portfolio_returns = BacktestPortfolio(names, startDate='2024-01-01', endDate='2025-10-24', leverage=1)
        logging.info("Portfolio backtest done")

    except Exception as e:
        logging.error(f"Error in backtesting: {e}")

    # –ó–∞–ø—É—Å–∫ —Ç–µ–ª–µ–≥—Ä–∞–º-–±–æ—Ç–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
    try:
        logging.info("Starting Telegram bot...")
        start_telegram_bot()  # –∑–∞–º–µ–Ω–∏ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ —Ç–≤–æ–µ–≥–æ telegram_bot.py
        logging.info("Telegram bot is running")
    except Exception as e:
        logging.error(f"Error in Telegram bot: {e}")

    # –ï—Å–ª–∏ –Ω—É–∂–Ω–æ, –º–æ–∂–Ω–æ –∑–∞–ø—É—Å–∫–∞—Ç—å –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
    while True:
        try:
            logging.info("Bot main loop tick...")
            # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ—Ä—Ç—Ñ–µ–ª—è
            time.sleep(60)
        except Exception as e:
            logging.error(f"Error in main loop: {e}")
            time.sleep(60)

if __name__ == "__main__":
    main()


===== pairs_core.py =====


import pandas as pd
import numpy as np
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller

def calculate_spread(df):
    # df: –∫–æ–ª–æ–Ω–∫–∏ ['A', 'B']
    X = sm.add_constant(df['B'])
    model = sm.OLS(df['A'], X).fit()
    beta = model.params[1]
    df['spread'] = df['A'] - beta * df['B']
    return df, beta

def test_stationarity(spread, significance=0.05):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å—Ç–∞—Ü–∏–æ–Ω–∞—Ä–µ–Ω –ª–∏ —Å–ø—Ä–µ–¥ —á–µ—Ä–µ–∑ ADF —Ç–µ—Å—Ç"""
    result = adfuller(spread)
    pvalue = result[1]
    return pvalue < significance

def generate_signals(df, window=35, entry_z=1, exit_z=0.5):
    df['mean'] = df['spread'].rolling(window).mean()
    df['std'] = df['spread'].rolling(window).std()
    df['zscore'] = (df['spread'] - df['mean']) / df['std']
    
    df['signal'] = 0
    df.loc[df['zscore'] > entry_z, 'signal'] = -1  # short spread
    df.loc[df['zscore'] < -entry_z, 'signal'] = 1  # long spread
    df.loc[df['zscore'].abs() < exit_z, 'signal'] = 0  # close
    
    return df

def BacktestPair(df, window=35, adf_threshold=0.05):
    df, beta = calculate_spread(df)
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–æ—Å—Ç—å —Å–ø—Ä–µ–¥–∞
    if not test_stationarity(df['spread'], significance=adf_threshold):
        print("–°–ø—Ä–µ–¥ –Ω–µ —Å—Ç–∞—Ü–∏–æ–Ω–∞—Ä–µ–Ω! –ü–∞—Ä–∞ –ø—Ä–æ–ø—É—â–µ–Ω–∞.")
        df['TotalReturn'] = 0
        return df
    
    df = generate_signals(df, window)
    df['TotalReturn'] = df['signal'].shift(1) * (df['spread'].diff())
    return df


===== telegram_bot.py =====


# telegram_bot.py - –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π Telegram –±–æ—Ç —Å –∫–Ω–æ–ø–∫–∞–º–∏
import requests
import json
import logging
from typing import Optional, List, Dict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TelegramBot:
    def __init__(self, token: str, chat_id: str):
        self.token = token
        self.chat_id = chat_id
        self.base_url = f"https://api.telegram.org/bot{token}"
        
    def safe_format_number(self, value, precision=2):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–µ–ª"""
        try:
            if value is None:
                return "N/A"
            return f"{float(value):.{precision}f}"
        except (ValueError, TypeError):
            return str(value)
        
    def send_message(self, text: str, buttons: Optional[List] = None) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–Ω–æ–ø–∫–∞–º–∏"""
        payload = {
            'chat_id': self.chat_id,
            'text': text,
            'parse_mode': 'HTML'
        }
        
        if buttons:
            payload['reply_markup'] = json.dumps({'inline_keyboard': buttons})
            
        try:
            response = requests.post(f"{self.base_url}/sendMessage", json=payload, timeout=10)
            return response.status_code == 200
        except Exception as e:
            logger.error(f"Failed to send message: {e}")
            return False
    
    def send_signal_alert(self, pair_data: Dict) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –¥–µ–π—Å—Ç–≤–∏–π"""
        try:
            pair_name = pair_data.get('pair_name', 'UNKNOWN')
            signal = pair_data.get('signal', 'NO_SIGNAL')
            z_score = pair_data.get('z_score')
            adf_passed = pair_data.get('adf_passed', False)
            price_a = pair_data.get('price_a')
            price_b = pair_data.get('price_b')
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
            z_display = self.safe_format_number(z_score, 2)
            price_a_display = self.safe_format_number(price_a, 2)
            price_b_display = self.safe_format_number(price_b, 2)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª
            formatted_signal = signal
            if "SHORT_" in signal and "LONG_" in signal:
                parts = signal.split('_')
                if len(parts) >= 4:
                    formatted_signal = f"SHORT {parts[1]} / LONG {parts[3]}"
            
            message = (
                f"üéØ <b>TRADING SIGNAL</b>\n"
                f"Pair: <b>{pair_name}</b>\n"
                f"Signal: <b>{formatted_signal}</b>\n"
                f"Z-score: {z_display}\n"
                f"ADF: {'‚úÖ PASSED' if adf_passed else '‚ùå FAILED'}\n"
                f"Prices: {price_a_display} | {price_b_display}"
            )
            
            # –ö–Ω–æ–ø–∫–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
            buttons = None
            if signal not in ['HOLD', 'NO_DATA', 'EXIT_POSITION']:
                buttons = [
                    [
                        {'text': 'üìà OPEN', 'callback_data': f'OPEN:{signal}:{pair_name}'},
                        {'text': '‚ùå CLOSE', 'callback_data': f'CLOSE:{signal}:{pair_name}'}
                    ]
                ]
            elif signal == 'EXIT_POSITION':
                buttons = [
                    [{'text': 'üî¥ CLOSE POSITION', 'callback_data': f'CLOSE:{signal}:{pair_name}'}]
                ]
                
            return self.send_message(message, buttons)
            
        except Exception as e:
            logger.error(f"Error in send_signal_alert: {e}")
            return self.send_message(f"‚ùå Error generating signal: {str(e)}")
    
    def send_status_report(self, report_data: Dict, open_positions: List = None) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ç–∞—Ç—É—Å –æ—Ç—á–µ—Ç–∞"""
        try:
            if not report_data:
                return self.send_message("‚ùå No report data available")
                
            open_positions = open_positions or []
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            total_pairs = report_data.get('total_pairs', 0)
            active_pairs = report_data.get('active_pairs', 0)
            trading_signals = report_data.get('trading_signals', 0)
            
            message = (
                f"üìä <b>PAIRS MONITORING STATUS</b>\n"
                f"Total Pairs: {total_pairs}\n"
                f"Active Pairs: {active_pairs}\n"
                f"Trading Signals: {trading_signals}\n"
                f"Open Positions: {len(open_positions)}"
            )
            
            # –î–µ—Ç–∞–ª–∏ –ø–æ –æ—Ç–∫—Ä—ã—Ç—ã–º –ø–æ–∑–∏—Ü–∏—è–º
            if open_positions:
                message += "\n\nüéØ <b>OPEN POSITIONS:</b>\n"
                for pos in open_positions[:5]:  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
                    pair_name = pos.get('pair', 'N/A')
                    signal = pos.get('signal', 'N/A')
                    message += f"‚Ä¢ {pair_name} - {signal}\n"
            
            # –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            buttons = [
                [
                    {'text': 'üìà Summary', 'callback_data': 'SUMMARY'},
                    {'text': 'üõë Close All', 'callback_data': 'CLOSE_ALL'}
                ],
                [
                    {'text': 'üîÑ Refresh', 'callback_data': 'REFRESH'}
                ]
            ]
            
            return self.send_message(message, buttons)
            
        except Exception as e:
            logger.error(f"Error in send_status_report: {e}")
            return self.send_message(f"‚ùå Error generating status report: {str(e)}")
    
    def handle_callback(self, callback_data: str, pair_analyzer, positions_manager) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ callback –æ—Ç –∫–Ω–æ–ø–æ–∫"""
        try:
            if callback_data == 'SUMMARY':
                report = pair_analyzer.get_analysis_report()
                return self.send_status_report(report, positions_manager.get_open_positions())
                
            elif callback_data == 'CLOSE_ALL':
                closed_count = positions_manager.close_all_positions()
                return self.send_message(f"‚úÖ Closed {closed_count} positions")
                
            elif callback_data == 'REFRESH':
                report = pair_analyzer.get_analysis_report()
                return self.send_status_report(report, positions_manager.get_open_positions())
                
            elif callback_data.startswith(('OPEN:', 'CLOSE:')):
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥
                try:
                    action, signal, pair_name = callback_data.split(':', 2)
                    if action == 'OPEN':
                        success = positions_manager.open_position(signal, pair_name)
                        msg = f"‚úÖ Opened position: {pair_name}" if success else f"‚ùå Failed to open: {pair_name}"
                    else:
                        success = positions_manager.close_position(signal, pair_name)
                        msg = f"‚úÖ Closed position: {pair_name}" if success else f"‚ùå Failed to close: {pair_name}"
                    return self.send_message(msg)
                except ValueError:
                    return self.send_message("‚ùå Invalid callback format")
                
            return self.send_message(f"‚ùå Unknown command: {callback_data}")
            
        except Exception as e:
            logger.error(f"Error handling callback: {e}")
            return self.send_message(f"‚ùå Error: {str(e)}")


class SimplePositionsManager:
    """–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–∑–∏—Ü–∏–π (–±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞)"""
    def __init__(self):
        self.open_positions = []
        
    def open_position(self, signal: str, pair_name: str) -> bool:
        """–û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ (–¥–µ–º–æ)"""
        try:
            position = {
                'pair': pair_name,
                'signal': signal,
                'size': 1000,
                'entry_time': '2024-10-24'
            }
            self.open_positions.append(position)
            logger.info(f"Opened position: {pair_name} - {signal}")
            return True
        except Exception as e:
            logger.error(f"Error opening position: {e}")
            return False
        
    def close_position(self, signal: str, pair_name: str) -> bool:
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ (–¥–µ–º–æ)"""
        try:
            initial_count = len(self.open_positions)
            self.open_positions = [p for p in self.open_positions if p['pair'] != pair_name]
            closed = initial_count - len(self.open_positions)
            logger.info(f"Closed position: {pair_name} ({closed} positions)")
            return closed > 0
        except Exception as e:
            logger.error(f"Error closing position: {e}")
            return False
        
    def close_all_positions(self) -> int:
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –ø–æ–∑–∏—Ü–∏–π"""
        try:
            count = len(self.open_positions)
            self.open_positions.clear()
            logger.info(f"Closed all {count} positions")
            return count
        except Exception as e:
            logger.error(f"Error closing all positions: {e}")
            return 0
        
    def get_open_positions(self) -> List:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π"""
        return self.open_positions.copy()
