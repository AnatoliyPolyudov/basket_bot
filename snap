

===== backtester.py =====


# backtester.py - –¢–ï–°–¢ –¢–û–ü-20 –ü–ê–†
import ccxt
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import argparse
from pairs_core import PairAnalyzer
from statsmodels.tsa.stattools import adfuller
import time

def fetch_historical_data(symbol: str, days: int = 365) -> pd.Series:
    """–ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö —Å OKX"""
    try:
        exchange = ccxt.okx({"enableRateLimit": True})
        ohlcv = exchange.fetch_ohlcv(symbol, '1d', limit=min(days, 365))
        
        dates = [pd.Timestamp(x[0], unit='ms') for x in ohlcv]
        closes = [x[4] for x in ohlcv]
        
        return pd.Series(closes, index=dates, name=symbol)
        
    except Exception as e:
        print(f"‚ùå Error loading {symbol}: {e}")
        return pd.Series()

def is_pair_cointegrated(spread_data, critical_value=-2.58):
    """ADF —Ç–µ—Å—Ç –∫–∞–∫ –≤ R - —Ç—Ä–æ–π–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞"""
    if len(spread_data) < 120:
        return False
        
    try:
        adf_120 = adfuller(spread_data[-120:], maxlag=1, regression='c', autolag=None)[0]
        if adf_120 > critical_value: return False
            
        adf_90 = adfuller(spread_data[-90:], maxlag=1, regression='c', autolag=None)[0]
        if adf_90 > critical_value: return False
            
        adf_60 = adfuller(spread_data[-60:], maxlag=1, regression='c', autolag=None)[0]
        if adf_60 > critical_value: return False
            
        return True
        
    except Exception as e:
        return False

def run_single_backtest(pair_name: str, target_pair: dict, days: int = 180, adf_test: bool = True):
    """–ë—ç–∫—Ç–µ—Å—Ç –æ–¥–Ω–æ–π –ø–∞—Ä—ã"""
    print(f"\nüîç Testing {pair_name}...")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    prices_a = fetch_historical_data(target_pair['asset_a'], days)
    prices_b = fetch_historical_data(target_pair['asset_b'], days)
    
    if prices_a.empty or prices_b.empty:
        print(f"‚ùå Failed to load data for {pair_name}")
        return None
    
    aligned_data = pd.DataFrame({
        'price_a': prices_a,
        'price_b': prices_b
    }).dropna()
    
    if len(aligned_data) < 130:
        print(f"‚ùå Not enough data for {pair_name}: {len(aligned_data)} days")
        return None
    
    aligned_data['spread'] = aligned_data['price_a'] / aligned_data['price_b']
    
    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã
    entry_z, exit_z = 1.0, 0.5
    stop_loss, max_hold_days, commission = 0.10, 30, 0.002
    
    # –ë—ç–∫—Ç–µ—Å—Ç–∏–Ω–≥
    returns = []
    positions = []
    entry_prices = {}
    
    for i in range(130, len(aligned_data)):
        window = aligned_data['spread'].iloc[i-35:i]
        current_spread = aligned_data['spread'].iloc[i]
        
        if window.std() > 0:
            z_score = (current_spread - window.mean()) / window.std()
        else:
            z_score = 0
        
        # ADF –ø—Ä–æ–≤–µ—Ä–∫–∞
        can_trade = True
        if adf_test:
            spread_history = aligned_data['spread'].iloc[:i+1]
            can_trade = is_pair_cointegrated(spread_history)
        
        # –¢–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è
        current_position = positions[-1] if positions else 0
        
        # –ü–†–û–í–ï–†–ö–ê –†–ò–°–ö-–ú–ï–ù–ï–î–ñ–ú–ï–ù–¢–ê
        force_exit = False
        force_exit_reason = ""
        
        if current_position != 0:
            entry_spread, entry_idx = entry_prices.get(current_position, (0, 0))
            days_in_position = i - entry_idx
            
            # –†–∞—Å—á–µ—Ç —Ç–µ–∫—É—â–µ–≥–æ PnL
            if current_position == 1:
                current_pnl = (current_spread - entry_spread) / entry_spread
            else:
                current_pnl = (entry_spread - current_spread) / entry_spread
            
            if current_pnl <= -stop_loss:
                force_exit = True
                force_exit_reason = f"STOP LOSS ({current_pnl*100:.1f}%)"
            elif days_in_position >= max_hold_days:
                force_exit = True
                force_exit_reason = f"MAX HOLD DAYS ({days_in_position} days)"
        
        # –õ–û–ì–ò–ö–ê –¢–†–ï–ô–î–ò–ù–ì–ê (–¢–û–õ–¨–ö–û –ï–°–õ–ò ADF –ü–†–û–ô–î–ï–ù)
        if force_exit:
            # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –≤—ã—Ö–æ–¥
            entry_spread, entry_idx = entry_prices[current_position]
            exit_spread = current_spread
            
            if current_position == 1:
                pnl = (exit_spread - entry_spread) / entry_spread
            else:
                pnl = (entry_spread - exit_spread) / entry_spread
            
            pnl -= commission
            returns.append(pnl)
            
            print(f"   üõë {force_exit_reason}")
            print(f"      PnL: {pnl*100:+.2f}%")
            
            del entry_prices[current_position]
            positions.append(0)
            
        elif current_position == 0 and can_trade:  # –ù–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ –ò ADF –ø—Ä–æ–π–¥–µ–Ω
            if z_score > entry_z:
                positions.append(-1)
                entry_prices[-1] = (current_spread, i)
                print(f"   üìà ENTRY SHORT: Z = {z_score:.2f}")
            elif z_score < -entry_z:
                positions.append(1)
                entry_prices[1] = (current_spread, i)
                print(f"   üìà ENTRY LONG: Z = {z_score:.2f}")
            else:
                positions.append(0)
                
        elif current_position == 1 and can_trade:  # Long –ø–æ–∑–∏—Ü–∏—è –ò ADF –ø—Ä–æ–π–¥–µ–Ω
            if z_score > -exit_z:
                entry_spread, entry_idx = entry_prices[1]
                exit_spread = current_spread
                
                pnl = (exit_spread - entry_spread) / entry_spread
                pnl -= commission
                
                returns.append(pnl)
                print(f"   üìâ EXIT LONG: Z = {z_score:.2f}, PnL: {pnl*100:+.2f}%")
                
                del entry_prices[1]
                positions.append(0)
            else:
                positions.append(1)
                
        elif current_position == -1 and can_trade:  # Short –ø–æ–∑–∏—Ü–∏—è –ò ADF –ø—Ä–æ–π–¥–µ–Ω
            if z_score < exit_z:
                entry_spread, entry_idx = entry_prices[-1]
                exit_spread = current_spread
                
                pnl = (entry_spread - exit_spread) / entry_spread
                pnl -= commission
                
                returns.append(pnl)
                print(f"   üìâ EXIT SHORT: Z = {z_score:.2f}, PnL: {pnl*100:+.2f}%")
                
                del entry_prices[-1]
                positions.append(0)
            else:
                positions.append(-1)
        else:
            # –ù–µ —Ç–æ—Ä–≥—É–µ–º - ADF –Ω–µ –ø—Ä–æ–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –ø–æ–∑–∏—Ü–∏–∏
            positions.append(current_position)
    
    # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –æ–¥–Ω–æ–π –ø–∞—Ä—ã
    if returns:
        returns_series = pd.Series(returns)
        total_return = (returns_series + 1).prod() - 1
        win_rate = (returns_series > 0).mean() * 100
        
        return {
            'pair': pair_name,
            'total_return': total_return,
            'win_rate': win_rate,
            'trades': len(returns),
            'avg_return': returns_series.mean(),
            'best_trade': returns_series.max(),
            'worst_trade': returns_series.min()
        }
    
    return None

def run_all_backtests(days: int = 180, adf_test: bool = True, min_trades: int = 3, limit: int = 20):
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ç–µ—Å—Ç –¢–û–ü-20 –ø–∞—Ä"""
    analyzer = PairAnalyzer(n_pairs=100)  # üëà –ë–µ—Ä–µ–º –∏–∑ 100 –≤–æ–∑–º–æ–∂–Ω—ã—Ö
    
    # üëá –û–ì–†–ê–ù–ò–ß–ò–í–ê–ï–ú –¢–û–ü-20 –ü–ê–†
    pairs_to_test = analyzer.pairs[:limit]
    
    print(f"üöÄ Testing TOP {len(pairs_to_test)} pairs (of {len(analyzer.pairs)} available)...")
    print(f"   Days: {days}, ADF Test: {adf_test}, Min Trades: {min_trades}")
    print("=" * 60)
    
    results = []
    
    for i, pair in enumerate(pairs_to_test):
        print(f"\nüìä {i+1}/{len(pairs_to_test)}: {pair['name']}")
        
        result = run_single_backtest(pair['name'], pair, days, adf_test)
        
        if result and result['trades'] >= min_trades:
            results.append(result)
            
            status = "‚úÖ PROFITABLE" if result['total_return'] > 0 else "‚ùå UNPROFITABLE"
            print(f"   {status} | Return: {result['total_return']*100:+.2f}% | Win Rate: {result['win_rate']:.1f}% | Trades: {result['trades']}")
        else:
            print(f"   ‚è© SKIPPED | Not enough trades or data")
    
    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    results.sort(key=lambda x: x['total_return'], reverse=True)
    
    # –í—ã–≤–æ–¥ –ª—É—á—à–∏—Ö –ø–∞—Ä
    print(f"\n{'='*60}")
    print(f"üéØ BEST PERFORMING PAIRS (Top 10)")
    print(f"{'='*60}")
    
    profitable_count = 0
    for i, result in enumerate(results[:10]):
        if result['total_return'] > 0:
            profitable_count += 1
            print(f"{i+1:2d}. {result['pair']:15} | Return: {result['total_return']*100:+.2f}% | Win Rate: {result['win_rate']:.1f}% | Trades: {result['trades']}")
    
    print(f"\nüìà Summary:")
    print(f"   Total Pairs Tested: {len(pairs_to_test)}")
    print(f"   Pairs with Enough Trades: {len(results)}")
    print(f"   Profitable Pairs: {profitable_count}")
    if len(results) > 0:
        print(f"   Success Rate: {profitable_count/len(results)*100:.1f}%")
    
    # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    if profitable_count > 0:
        print(f"\nüí° Recommended pairs for monitoring:")
        for result in results[:5]:
            if result['total_return'] > 0:
                print(f"   {result['pair']} (+{result['total_return']*100:.1f}%)")

def main():
    parser = argparse.ArgumentParser(description='Backtest pairs like in R')
    parser.add_argument('--pair', type=str, help='Test single pair (e.g., BTC_ETH)')
    parser.add_argument('--all', action='store_true', help='Test TOP 20 pairs automatically')
    parser.add_argument('--days', type=int, default=180, help='Days of historical data')
    parser.add_argument('--noadf', action='store_true', help='Disable ADF test')
    parser.add_argument('--limit', type=int, default=20, help='Limit number of pairs to test (default: 20)')
    
    args = parser.parse_args()
    
    if args.all:
        run_all_backtests(days=args.days, adf_test=not args.noadf, limit=args.limit)
    elif args.pair:
        # –ó–∞–ø—É—Å–∫ –¥–ª—è –æ–¥–Ω–æ–π –ø–∞—Ä—ã
        analyzer = PairAnalyzer()
        target_pair = None
        for pair in analyzer.pairs:
            if pair['name'] == args.pair:
                target_pair = pair
                break
        
        if target_pair:
            result = run_single_backtest(args.pair, target_pair, args.days, not args.noadf)
            if result:
                print(f"\nüéØ RESULT for {args.pair}:")
                print(f"   Total Return: {result['total_return']*100:+.2f}%")
                print(f"   Win Rate: {result['win_rate']:.1f}%")
                print(f"   Trades: {result['trades']}")
        else:
            print(f"‚ùå Pair {args.pair} not found")
    else:
        print("‚ùå Specify --pair <name> or --all to test top 20 pairs")

if __name__ == "__main__":
    main()


===== main.py =====


# main.py - –ì–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è –∑–∞–ø—É—Å–∫–∞
import time
import logging
import os
from pairs_core import PairAnalyzer
from telegram_bot import TelegramBot, SimplePositionsManager

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def main():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
    analyzer = PairAnalyzer()
    positions_manager = SimplePositionsManager()
    
    # Telegram –±–æ—Ç (—Ç–æ–∫–µ–Ω –∏–∑ .env)
    telegram_token = os.getenv('TELEGRAM_BOT_TOKEN', '8436652130:AAF6On0GJtRHfMZyqD3mpM57eXZfWofJeng')
    chat_id = os.getenv('TELEGRAM_CHAT_ID', '317217451')
    
    bot = TelegramBot(telegram_token, chat_id)
    
    logger.info("üöÄ Starting Simplified Pairs Monitor...")
    bot.send_message("ü§ñ Pairs Monitor Started!")
    
    # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    while True:
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∞–Ω–∞–ª–∏–∑ –ø–∞—Ä
            report = analyzer.get_analysis_report()
            
            if 'error' not in report:
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
                bot.send_status_report(report, positions_manager.get_open_positions())
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª—ã
                for pair_data in report['pairs_data']:
                    signal = pair_data.get('signal')
                    if signal not in ['HOLD', 'NO_DATA']:
                        bot.send_signal_alert(pair_data)
            
            # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
            time.sleep(600)  # 10 –º–∏–Ω—É—Ç
            
        except KeyboardInterrupt:
            logger.info("üõë Monitor stopped by user")
            bot.send_message("üõë Pairs Monitor Stopped")
            break
        except Exception as e:
            logger.error(f"‚ùå Error in main loop: {e}")
            time.sleep(60)

if __name__ == "__main__":
    main()


===== pairs_core.py =====


# pairs_core.py - –î–ò–ù–ê–ú–ò–ß–ï–°–ö–ò–ô –¢–û–ü –ü–ê–† –° OKX
import ccxt
import pandas as pd
import numpy as np
from statsmodels.tsa.stattools import adfuller
from scipy.stats import zscore
import logging
from typing import List, Dict, Optional
import time

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class PairAnalyzer:
    def __init__(self, n_pairs: int = 30):
        self.exchange = ccxt.okx({
            "enableRateLimit": True,
            "options": {"defaultType": "swap"}
        })
        self.n_pairs = n_pairs
        self.pairs = self.get_dynamic_top_pairs(n_pairs)
        
    def get_dynamic_top_pairs(self, n_pairs: int) -> List[Dict]:
        """–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –ø–æ–ª—É—á–∞–µ—Ç —Ç–æ–ø –ø–∞—Ä –ø–æ –æ–±—ä–µ–º—É —Å OKX"""
        try:
            print(f"üìä Fetching top {n_pairs} pairs from OKX...")
            
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ä—ã–Ω–∫–∏
            markets = self.exchange.load_markets()
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º USDT –ø–∞—Ä—ã —Å–ø–æ—Ç-–º–∞—Ä–∫–µ—Ç
            usdt_pairs = [
                symbol for symbol in markets 
                if symbol.endswith('/USDT:USDT') and markets[symbol]['active']
            ]
            
            print(f"üìà Found {len(usdt_pairs)} active USDT pairs")
            
            # –ü–æ–ª—É—á–∞–µ–º –æ–±—ä–µ–º—ã –¥–ª—è —Ç–æ–ø –ø–∞—Ä (–ª–∏–º–∏—Ç–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å—ã)
            top_symbols = []
            batch_size = 20
            
            for i in range(0, min(100, len(usdt_pairs)), batch_size):
                batch = usdt_pairs[i:i + batch_size]
                try:
                    tickers = self.exchange.fetch_tickers(batch)
                    
                    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –æ–±—ä–µ–º—É (baseVolume)
                    batch_volumes = []
                    for symbol in batch:
                        if symbol in tickers and tickers[symbol].get('baseVolume'):
                            volume = tickers[symbol]['baseVolume']
                            batch_volumes.append((symbol, volume))
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ø –∏–∑ –±–∞—Ç—á–∞
                    batch_volumes.sort(key=lambda x: x[1], reverse=True)
                    top_symbols.extend([s[0] for s in batch_volumes[:10]])
                    
                    time.sleep(0.5)  # Rate limiting
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Error fetching batch: {e}")
                    continue
            
            # –ë–µ—Ä–µ–º —Ç–æ–ø N —Å–∏–º–≤–æ–ª–æ–≤ –ø–æ –æ–±—ä–µ–º—É
            top_symbols = list(dict.fromkeys(top_symbols))[:n_pairs * 2]  # –ë–µ—Ä–µ–º –≤ 2 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø–∞—Ä
            
            print(f"üéØ Top {len(top_symbols)} symbols by volume: {[s.split('/')[0] for s in top_symbols[:10]]}...")
            
            # –°–æ–∑–¥–∞–µ–º –ø–∞—Ä—ã –∏–∑ —Ç–æ–ø —Å–∏–º–≤–æ–ª–æ–≤
            pairs = []
            max_pairs_per_symbol = 3  # –ú–∞–∫—Å–∏–º—É–º –ø–∞—Ä –Ω–∞ –æ–¥–∏–Ω —Å–∏–º–≤–æ–ª
            
            for i, symbol_a in enumerate(top_symbols):
                symbol_a_name = symbol_a.split('/')[0]
                pairs_added = 0
                
                for j, symbol_b in enumerate(top_symbols[i+1:], i+1):
                    if pairs_added >= max_pairs_per_symbol:
                        break
                        
                    symbol_b_name = symbol_b.split('/')[0]
                    
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–∞—Ä—ã —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –±–∞–∑–æ–π
                    if symbol_a_name != symbol_b_name:
                        pairs.append({
                            'asset_a': symbol_a,
                            'asset_b': symbol_b,
                            'name': f"{symbol_a_name}_{symbol_b_name}",
                            'base_volume_a': self.get_symbol_volume(symbol_a),
                            'base_volume_b': self.get_symbol_volume(symbol_b)
                        })
                        pairs_added += 1
                
                if len(pairs) >= n_pairs:
                    break
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–∞—Ä—ã –ø–æ —Å–æ–≤–æ–∫—É–ø–Ω–æ–º—É –æ–±—ä–µ–º—É
            pairs.sort(key=lambda x: (x.get('base_volume_a', 0) + x.get('base_volume_b', 0)), reverse=True)
            pairs = pairs[:n_pairs]
            
            print(f"‚úÖ Created {len(pairs)} trading pairs")
            print(f"üìã Sample pairs: {[p['name'] for p in pairs[:5]]}...")
            
            return pairs
            
        except Exception as e:
            print(f"‚ùå Error fetching dynamic pairs: {e}")
            return self.get_fallback_pairs(n_pairs)
    
    def get_symbol_volume(self, symbol: str) -> float:
        """–ü–æ–ª—É—á–∞–µ—Ç –æ–±—ä–µ–º –¥–ª—è —Å–∏–º–≤–æ–ª–∞"""
        try:
            ticker = self.exchange.fetch_ticker(symbol)
            return ticker.get('baseVolume', 0)
        except:
            return 0
    
    def get_fallback_pairs(self, n_pairs: int) -> List[Dict]:
        """–†–µ–∑–µ—Ä–≤–Ω—ã–µ –ø–∞—Ä—ã –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ"""
        print("üîÑ Using fallback pair list...")
        
        fallback_symbols = [
            "BTC/USDT:USDT", "ETH/USDT:USDT", "BNB/USDT:USDT", "SOL/USDT:USDT",
            "XRP/USDT:USDT", "ADA/USDT:USDT", "AVAX/USDT:USDT", "DOT/USDT:USDT",
            "LINK/USDT:USDT", "LTC/USDT:USDT", "ATOM/USDT:USDT", "DOGE/USDT:USDT",
            "MATIC/USDT:USDT", "TRX/USDT:USDT", "XLM/USDT:USDT", "BCH/USDT:USDT",
            "FIL/USDT:USDT", "ETC/USDT:USDT", "EOS/USDT:USDT", "AAVE/USDT:USDT"
        ]
        
        pairs = []
        for i in range(min(10, len(fallback_symbols))):
            for j in range(i + 1, min(i + 6, len(fallback_symbols))):
                asset_a = fallback_symbols[i]
                asset_b = fallback_symbols[j]
                name_a = asset_a.split('/')[0]
                name_b = asset_b.split('/')[0]
                
                pairs.append({
                    'asset_a': asset_a,
                    'asset_b': asset_b,
                    'name': f"{name_a}_{name_b}"
                })
                
                if len(pairs) >= n_pairs:
                    return pairs
        return pairs
    
    def get_current_prices(self) -> Optional[Dict]:
        """–¢–µ–∫—É—â–∏–µ —Ü–µ–Ω—ã –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤"""
        try:
            symbols = list(set([p['asset_a'] for p in self.pairs] + [p['asset_b'] for p in self.pairs]))
            all_prices = {}
            
            # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –±–∞—Ç—á–∏ —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ª–∏–º–∏—Ç–æ–≤
            batch_size = 10
            for i in range(0, len(symbols), batch_size):
                batch = symbols[i:i + batch_size]
                try:
                    tickers = self.exchange.fetch_tickers(batch)
                    for symbol in batch:
                        if symbol in tickers and tickers[symbol].get('last'):
                            all_prices[symbol] = tickers[symbol]['last']
                    time.sleep(0.3)
                except Exception as e:
                    logger.warning(f"Batch price error: {e}")
            
            return all_prices
        except Exception as e:
            logger.error(f"Error fetching prices: {e}")
            return None

    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    def calculate_spread(self, pair: Dict, prices: Dict) -> Optional[float]:
        """–†–∞—Å—á–µ—Ç —Å–ø—Ä–µ–¥–∞ –º–µ–∂–¥—É –ø–∞—Ä–æ–π"""
        try:
            price_a = prices.get(pair['asset_a'])
            price_b = prices.get(pair['asset_b'])
            if price_a and price_b and price_b > 0:
                return price_a / price_b
        except Exception as e:
            logger.error(f"Error calculating spread for {pair['name']}: {e}")
        return None
    
    def analyze_pair(self, pair: Dict, prices: Dict, historical_data: List[float]) -> Dict:
        """–ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –æ–¥–Ω–æ–π –ø–∞—Ä—ã"""
        current_spread = self.calculate_spread(pair, prices)
        if not current_spread or not historical_data:
            return {
                'pair_name': pair['name'],
                'signal': 'NO_DATA',
                'z_score': None,
                'adf_passed': False,
                'current_spread': current_spread
            }
        
        # ADF —Ç–µ—Å—Ç (–≥–æ—Ç–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π)
        if len(historical_data) >= 60:
            adf_stat = adfuller(historical_data, maxlag=1)[0]
            adf_passed = adf_stat < -2.0
        else:
            adf_passed = False
        
        # Z-score (–≥–æ—Ç–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π)
        if len(historical_data) >= 20:
            z_scores = zscore(historical_data, ddof=1)
            current_z = z_scores[-1] if not np.isnan(z_scores[-1]) else None
        else:
            current_z = None
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–∞
        signal = self.generate_signal(current_z, adf_passed, pair['name'])
        
        return {
            'pair_name': pair['name'],
            'signal': signal,
            'z_score': current_z,
            'adf_passed': adf_passed,
            'current_spread': current_spread,
            'price_a': prices.get(pair['asset_a']),
            'price_b': prices.get(pair['asset_b'])
        }
    
    def generate_signal(self, z_score: Optional[float], adf_passed: bool, pair_name: str) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞"""
        if z_score is None or not adf_passed:
            return "NO_DATA"
        
        if z_score > 1.0:
            return f"SHORT_{pair_name.split('_')[0]}_LONG_{pair_name.split('_')[1]}"
        elif z_score < -1.0:
            return f"LONG_{pair_name.split('_')[0]}_SHORT_{pair_name.split('_')[1]}"
        elif abs(z_score) < 0.5:
            return "EXIT_POSITION"
        else:
            return "HOLD"
    
    def get_analysis_report(self) -> Dict:
        """–ü–æ–ª–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –≤—Å–µ–º –ø–∞—Ä–∞–º"""
        prices = self.get_current_prices()
        if not prices:
            return {'error': 'Failed to fetch prices'}
        
        report = {
            'timestamp': pd.Timestamp.now(),
            'pairs_data': [],
            'total_pairs': len(self.pairs),
            'active_pairs': 0,
            'trading_signals': 0
        }
        
        for pair in self.pairs:
            # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∞—è data
            # –î–ª—è –¥–µ–º–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            historical_data = np.random.normal(1.0, 0.1, 100).tolist()
            
            pair_analysis = self.analyze_pair(pair, prices, historical_data)
            report['pairs_data'].append(pair_analysis)
            
            if pair_analysis['adf_passed']:
                report['active_pairs'] += 1
            if pair_analysis['signal'] not in ['HOLD', 'NO_DATA']:
                report['trading_signals'] += 1
        
        return report


===== pairs_history.py =====


class HistoryStorage:
    def __init__(self):
        self.data = {}

    def add_point(self, pair_name: str, value: float):
        if pair_name not in self.data:
            self.data[pair_name] = []
        self.data[pair_name].append(value)

        if len(self.data[pair_name]) > 300:
            self.data[pair_name] = self.data[pair_name][-300:]

    def get_history(self, pair_name: str):
        return self.data.get(pair_name, [])


===== telegram_bot.py =====


# telegram_bot.py - –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π Telegram –±–æ—Ç —Å –∫–Ω–æ–ø–∫–∞–º–∏
import requests
import json
import logging
from typing import Optional, List, Dict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TelegramBot:
    def __init__(self, token: str, chat_id: str):
        self.token = token
        self.chat_id = chat_id
        self.base_url = f"https://api.telegram.org/bot{token}"
        
    def safe_format_number(self, value, precision=2):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–µ–ª"""
        try:
            if value is None:
                return "N/A"
            return f"{float(value):.{precision}f}"
        except (ValueError, TypeError):
            return str(value)
        
    def send_message(self, text: str, buttons: Optional[List] = None) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–Ω–æ–ø–∫–∞–º–∏"""
        payload = {
            'chat_id': self.chat_id,
            'text': text,
            'parse_mode': 'HTML'
        }
        
        if buttons:
            payload['reply_markup'] = json.dumps({'inline_keyboard': buttons})
            
        try:
            response = requests.post(f"{self.base_url}/sendMessage", json=payload, timeout=10)
            return response.status_code == 200
        except Exception as e:
            logger.error(f"Failed to send message: {e}")
            return False
    
    def send_signal_alert(self, pair_data: Dict) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –¥–µ–π—Å—Ç–≤–∏–π"""
        try:
            pair_name = pair_data.get('pair_name', 'UNKNOWN')
            signal = pair_data.get('signal', 'NO_SIGNAL')
            z_score = pair_data.get('z_score')
            adf_passed = pair_data.get('adf_passed', False)
            price_a = pair_data.get('price_a')
            price_b = pair_data.get('price_b')
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
            z_display = self.safe_format_number(z_score, 2)
            price_a_display = self.safe_format_number(price_a, 2)
            price_b_display = self.safe_format_number(price_b, 2)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª
            formatted_signal = signal
            if "SHORT_" in signal and "LONG_" in signal:
                parts = signal.split('_')
                if len(parts) >= 4:
                    formatted_signal = f"SHORT {parts[1]} / LONG {parts[3]}"
            
            message = (
                f"üéØ <b>TRADING SIGNAL</b>\n"
                f"Pair: <b>{pair_name}</b>\n"
                f"Signal: <b>{formatted_signal}</b>\n"
                f"Z-score: {z_display}\n"
                f"ADF: {'‚úÖ PASSED' if adf_passed else '‚ùå FAILED'}\n"
                f"Prices: {price_a_display} | {price_b_display}"
            )
            
            # –ö–Ω–æ–ø–∫–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
            buttons = None
            if signal not in ['HOLD', 'NO_DATA', 'EXIT_POSITION']:
                buttons = [
                    [
                        {'text': 'üìà OPEN', 'callback_data': f'OPEN:{signal}:{pair_name}'},
                        {'text': '‚ùå CLOSE', 'callback_data': f'CLOSE:{signal}:{pair_name}'}
                    ]
                ]
            elif signal == 'EXIT_POSITION':
                buttons = [
                    [{'text': 'üî¥ CLOSE POSITION', 'callback_data': f'CLOSE:{signal}:{pair_name}'}]
                ]
                
            return self.send_message(message, buttons)
            
        except Exception as e:
            logger.error(f"Error in send_signal_alert: {e}")
            return self.send_message(f"‚ùå Error generating signal: {str(e)}")
    
    def send_status_report(self, report_data: Dict, open_positions: List = None) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å—Ç–∞—Ç—É—Å –æ—Ç—á–µ—Ç–∞"""
        try:
            if not report_data:
                return self.send_message("‚ùå No report data available")
                
            open_positions = open_positions or []
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            total_pairs = report_data.get('total_pairs', 0)
            active_pairs = report_data.get('active_pairs', 0)
            trading_signals = report_data.get('trading_signals', 0)
            
            message = (
                f"üìä <b>PAIRS MONITORING STATUS</b>\n"
                f"Total Pairs: {total_pairs}\n"
                f"Active Pairs: {active_pairs}\n"
                f"Trading Signals: {trading_signals}\n"
                f"Open Positions: {len(open_positions)}"
            )
            
            # –î–µ—Ç–∞–ª–∏ –ø–æ –æ—Ç–∫—Ä—ã—Ç—ã–º –ø–æ–∑–∏—Ü–∏—è–º
            if open_positions:
                message += "\n\nüéØ <b>OPEN POSITIONS:</b>\n"
                for pos in open_positions[:5]:  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
                    pair_name = pos.get('pair', 'N/A')
                    signal = pos.get('signal', 'N/A')
                    message += f"‚Ä¢ {pair_name} - {signal}\n"
            
            # –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            buttons = [
                [
                    {'text': 'üìà Summary', 'callback_data': 'SUMMARY'},
                    {'text': 'üõë Close All', 'callback_data': 'CLOSE_ALL'}
                ],
                [
                    {'text': 'üîÑ Refresh', 'callback_data': 'REFRESH'}
                ]
            ]
            
            return self.send_message(message, buttons)
            
        except Exception as e:
            logger.error(f"Error in send_status_report: {e}")
            return self.send_message(f"‚ùå Error generating status report: {str(e)}")
    
    def handle_callback(self, callback_data: str, pair_analyzer, positions_manager) -> bool:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ callback –æ—Ç –∫–Ω–æ–ø–æ–∫"""
        try:
            if callback_data == 'SUMMARY':
                report = pair_analyzer.get_analysis_report()
                return self.send_status_report(report, positions_manager.get_open_positions())
                
            elif callback_data == 'CLOSE_ALL':
                closed_count = positions_manager.close_all_positions()
                return self.send_message(f"‚úÖ Closed {closed_count} positions")
                
            elif callback_data == 'REFRESH':
                report = pair_analyzer.get_analysis_report()
                return self.send_status_report(report, positions_manager.get_open_positions())
                
            elif callback_data.startswith(('OPEN:', 'CLOSE:')):
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥
                try:
                    action, signal, pair_name = callback_data.split(':', 2)
                    if action == 'OPEN':
                        success = positions_manager.open_position(signal, pair_name)
                        msg = f"‚úÖ Opened position: {pair_name}" if success else f"‚ùå Failed to open: {pair_name}"
                    else:
                        success = positions_manager.close_position(signal, pair_name)
                        msg = f"‚úÖ Closed position: {pair_name}" if success else f"‚ùå Failed to close: {pair_name}"
                    return self.send_message(msg)
                except ValueError:
                    return self.send_message("‚ùå Invalid callback format")
                
            return self.send_message(f"‚ùå Unknown command: {callback_data}")
            
        except Exception as e:
            logger.error(f"Error handling callback: {e}")
            return self.send_message(f"‚ùå Error: {str(e)}")


class SimplePositionsManager:
    """–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–∑–∏—Ü–∏–π (–±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞)"""
    def __init__(self):
        self.open_positions = []
        
    def open_position(self, signal: str, pair_name: str) -> bool:
        """–û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ (–¥–µ–º–æ)"""
        try:
            position = {
                'pair': pair_name,
                'signal': signal,
                'size': 1000,
                'entry_time': '2024-10-24'
            }
            self.open_positions.append(position)
            logger.info(f"Opened position: {pair_name} - {signal}")
            return True
        except Exception as e:
            logger.error(f"Error opening position: {e}")
            return False
        
    def close_position(self, signal: str, pair_name: str) -> bool:
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ (–¥–µ–º–æ)"""
        try:
            initial_count = len(self.open_positions)
            self.open_positions = [p for p in self.open_positions if p['pair'] != pair_name]
            closed = initial_count - len(self.open_positions)
            logger.info(f"Closed position: {pair_name} ({closed} positions)")
            return closed > 0
        except Exception as e:
            logger.error(f"Error closing position: {e}")
            return False
        
    def close_all_positions(self) -> int:
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –ø–æ–∑–∏—Ü–∏–π"""
        try:
            count = len(self.open_positions)
            self.open_positions.clear()
            logger.info(f"Closed all {count} positions")
            return count
        except Exception as e:
            logger.error(f"Error closing all positions: {e}")
            return 0
        
    def get_open_positions(self) -> List:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π"""
        return self.open_positions.copy()
