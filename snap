

===== callback_handler.py =====


def handle_callback(callback_data, trader, telegram_observer=None, current_data=None):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –∫–Ω–æ–ø–æ–∫ Telegram
    """
    try:
        if callback_data in ['SUMMARY', 'CLOSE_ALL', 'ENABLE_AUTO', 'DISABLE_AUTO', 'EXPORT_LOG']:
            if telegram_observer:
                telegram_observer.handle_management_callback(callback_data, trader, current_data)
            return
            
        parts = callback_data.split(":", 2)
        if len(parts) == 3:
            action, signal, pair_name = parts
        elif len(parts) == 2:
            action, signal = parts
            pair_name = "UNKNOWN"
        else:
            print(f"‚ùå Invalid callback format: {callback_data}")
            return
            
        if trader is None:
            print("‚ùå Trader not provided for callback")
            return

        if action == "OPEN":
            trader.open_position(f"MANUAL_{signal}", pair_name)
        elif action == "CLOSE":
            trader.close_position(signal, pair_name, "Manual close from Telegram")
        else:
            print(f"‚ùå Unknown callback action: {action}")
    except Exception as e:
        print(f"‚ùå Callback handler error: {e}")

===== console_observer.py =====


from observer import Observer
from datetime import datetime

class ConsoleObserver(Observer):
    def update(self, data):
        # üÜï –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –ù–û–í–´–ô –§–û–†–ú–ê–¢ –î–ê–ù–ù–´–•
        pairs_data = data.get('pairs_data', [])
        total_pairs = data.get('total_pairs', 0)
        active_pairs = data.get('active_pairs', 0)
        
        print(f"[{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}] R-STYLE PAIR MONITOR")
        print(f"Active Pairs: {active_pairs}/{total_pairs}")
        print("-" * 50)
        
        for pair_data in pairs_data:
            pair_name = pair_data.get('pair_name', 'UNKNOWN')
            signal = pair_data.get('signal', 'NO DATA')
            z_score = pair_data.get('z', 0)
            spread = pair_data.get('spread', 0)
            adf_passed = pair_data.get('adf_passed', False)
            
            print(f"Pair: {pair_name}")
            print(f"  Signal: {signal}")
            print(f"  Z-score: {z_score:.4f}")
            print(f"  Spread: {spread:.6f}")
            print(f"  ADF: {'PASSED' if adf_passed else 'FAILED'}")
            print(f"  Prices: {pair_data.get('asset_a', '')}={pair_data.get('price_a', 0):.2f} | {pair_data.get('asset_b', '')}={pair_data.get('price_b', 0):.2f}")
            print("-" * 30)

===== monitor.py =====


import ccxt
import pandas as pd
import numpy as np
import time
import logging
from datetime import datetime, timedelta
from observer import Subject
from console_observer import ConsoleObserver
from trader import OKXBasketTrader
from telegram_observer import TelegramObserver
from callback_handler import handle_callback
import threading
import requests
import sys
from statsmodels.tsa.stattools import adfuller
import warnings
warnings.filterwarnings('ignore')

# üéØ –ò–ú–ü–û–†–¢–ò–†–£–ï–ú –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Æ –ü–ê–†
from pairs_config import get_preset, PAIR_PRESETS

logging.basicConfig(level=logging.INFO, format="%(message)s")
logger = logging.getLogger(__name__)

class RStylePairMonitor(Subject):
    def __init__(self, pair_preset="ultra_liquid_8"):
        super().__init__()
        self.exchange = ccxt.okx({
            "enableRateLimit": True,
            "options": {"defaultType": "swap"},
            "sandbox": False
        })
        
        # üéØ –ó–ê–ì–†–£–ñ–ê–ï–ú –ü–ê–†–´ –ò–ó –ö–û–ù–§–ò–ì–ê
        self.trading_pairs = get_preset(pair_preset)
        if not self.trading_pairs:
            logger.error(f"‚ùå Preset '{pair_preset}' not found! Using default.")
            self.trading_pairs = get_preset("ultra_liquid_8")
        
        logger.info(f"üéØ Loaded {len(self.trading_pairs)} pairs from preset: {pair_preset}")
        
        # –í—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö
        self.all_symbols = set()
        for pair in self.trading_pairs:
            self.all_symbols.add(pair["asset_a"])
            self.all_symbols.add(pair["asset_b"])
        self.all_symbols = list(self.all_symbols)
        
        self.historical_data = {}
        self.timeframe = "1h"  # –£–ø—Ä–æ—Å—Ç–∏–ª–∏ timeframe –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
        self.lookback_bars = 100  # –£–º–µ–Ω—å—à–∏–ª–∏ —Å 672 –¥–æ 100
        self.data_loaded = False
        self.window_bars = 20  # –£–º–µ–Ω—å—à–∏–ª–∏ –æ–∫–Ω–æ –¥–ª—è Z-score
        
        # ADF –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–µ)
        self.adf_lookbacks = [30, 20]  # –ú–µ–Ω—å—à–µ –±–∞—Ä–æ–≤ –¥–ª—è —Ç–µ—Å—Ç–∞
        self.adf_critical_value = -1.5  # –ë–æ–ª–µ–µ –º—è–≥–∫–∏–π –∫—Ä–∏—Ç–µ—Ä–∏–π
        
        # –•—Ä–∞–Ω–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã
        self.pair_states = {}
        for pair in self.trading_pairs:
            self.pair_states[pair["name"]] = {
                'current_signal': 'HOLD',
                'adf_passed': False,
                'position_open': False,
                'data_loaded': False
            }
        
        # üÜï –î–õ–Ø –ü–ï–†–ï–î–ê–ß–ò –î–ê–ù–ù–´–• –í TELEGRAM
        self.current_report_data = None
        
    def complete_data_reset(self):
        """–ü–û–õ–ù–´–ô –°–ë–†–û–° –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö –∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞"""
        logger.info("üóëÔ∏è COMPLETE DATA RESET INITIATED...")
        logger.info(f"üéØ Loading data for {len(self.all_symbols)} symbols and {len(self.trading_pairs)} pairs")
        
        self.historical_data = {}
        self.data_loaded = False
        
        if self.fetch_historical_data():
            logger.info("‚úÖ COMPLETE RESET SUCCESSFUL - Fresh data loaded")
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º ADF –¥–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã
            successful_pairs = 0
            for pair in self.trading_pairs:
                spread_data = self.get_pair_historical_spread(pair)
                if spread_data is not None:
                    adf_passed = self.calculate_adf_test(spread_data)
                    self.pair_states[pair["name"]]['data_loaded'] = True
                    self.pair_states[pair["name"]]['adf_passed'] = adf_passed
                    if adf_passed:
                        successful_pairs += 1
                    logger.info(f"üìä {pair['name']}: ADF {'PASSED' if adf_passed else 'FAILED'}")
                else:
                    logger.warning(f"‚ùå {pair['name']}: No historical data")
            
            logger.info(f"üéØ Successfully initialized {successful_pairs}/{len(self.trading_pairs)} pairs")
            return True
        else:
            logger.error("‚ùå COMPLETE RESET FAILED")
            return False
        
    def fetch_historical_data(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤"""
        if self.data_loaded:
            logger.info("üìä Historical data already loaded, skipping...")
            return True
            
        logger.info(f"üîÑ FETCHING DATA FOR {len(self.all_symbols)} SYMBOLS FROM OKX...")
        
        success_count = 0
        for symbol in self.all_symbols:
            try:
                logger.info(f"üì• Loading {symbol}...")
                ohlcv = self.exchange.fetch_ohlcv(symbol, self.timeframe, limit=self.lookback_bars)
                if ohlcv and len(ohlcv) >= 50:  # –£–º–µ–Ω—å—à–∏–ª–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–µ
                    self.historical_data[symbol] = [c[4] for c in ohlcv]
                    success_count += 1
                    logger.info(f"‚úÖ {symbol}: {len(self.historical_data[symbol])} bars")
                else:
                    logger.warning(f"‚ùå No data for {symbol} - got {len(ohlcv) if ohlcv else 0} bars")
            except Exception as e:
                logger.warning(f"‚ùå Error loading {symbol}: {e}")
        
        # –¢—Ä–µ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∫–∏ —Ö–æ—Ç—è –±—ã 60% —Å–∏–º–≤–æ–ª–æ–≤
        min_required = max(3, len(self.all_symbols) * 0.6)
        if success_count >= min_required:
            self.data_loaded = True
            logger.info(f"üéØ Successfully loaded {success_count}/{len(self.all_symbols)} symbols")
            return True
        else:
            logger.error(f"‚ùå Not enough valid symbols: {success_count}/{len(self.all_symbols)} (need at least {min_required})")
            return False

    def get_pair_historical_spread(self, pair):
        """–ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–π —Å–ø—Ä–µ–¥ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø–∞—Ä—ã"""
        if pair["asset_a"] not in self.historical_data:
            return None
        if pair["asset_b"] not in self.historical_data:
            return None
            
        len_a = len(self.historical_data[pair["asset_a"]])
        len_b = len(self.historical_data[pair["asset_b"]])
        
        min_len = min(len_a, len_b)
        
        if min_len < max(self.adf_lookbacks):
            return None
            
        prices_a = np.array(self.historical_data[pair["asset_a"]][-min_len:])
        prices_b = np.array(self.historical_data[pair["asset_b"]][-min_len:])
        
        spread = prices_a / prices_b
        return spread

    def calculate_adf_test(self, spread_data):
        """ADF —Ç–µ—Å—Ç –Ω–∞ —Å—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–æ—Å—Ç—å"""
        if spread_data is None or len(spread_data) < max(self.adf_lookbacks):
            return False
        
        try:
            adf_passed = True
            
            for lookback in self.adf_lookbacks:
                if len(spread_data) < lookback:
                    adf_passed = False
                    break
                    
                test_data = spread_data[-lookback:]
                adf_result = adfuller(test_data, maxlag=1, regression='c', autolag=None)
                adf_statistic = adf_result[0]
                
                if adf_statistic > self.adf_critical_value:
                    adf_passed = False
                    break
            
            return adf_passed
            
        except Exception as e:
            logger.warning(f"‚ùå ADF test error: {e}")
            return False

    def calculate_pair_spread(self, pair, current_prices):
        """–¢–µ–∫—É—â–∏–π —Å–ø—Ä–µ–¥ –¥–ª—è –ø–∞—Ä—ã: Asset_A / Asset_B"""
        if pair["asset_a"] not in current_prices or pair["asset_b"] not in current_prices:
            return None
            
        price_a = current_prices[pair["asset_a"]]
        price_b = current_prices[pair["asset_b"]]
        
        if price_a <= 0 or price_b <= 0:
            return None
            
        spread = price_a / price_b
        return spread

    def calculate_zscore_for_pair(self, pair, current_prices):
        """Z-score –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø–∞—Ä—ã –Ω–∞ —Å–∫–æ–ª—å–∑—è—â–µ–º –æ–∫–Ω–µ"""
        current_spread = self.calculate_pair_spread(pair, current_prices)
        if current_spread is None:
            return None, None, None
            
        historical_spread = self.get_pair_historical_spread(pair)
        if historical_spread is None or len(historical_spread) < self.window_bars:
            return None, None, None
        
        window_data = historical_spread[-self.window_bars:]
        
        mean = np.mean(window_data)
        std = np.std(window_data)
        
        if std < 1e-10:
            return None, None, None
            
        z = (current_spread - mean) / std
        
        # üÜï –ü–†–û–í–ï–†–ö–ê –ù–ê NaN –ò INF –ò –ù–ï–í–ê–õ–ò–î–ù–´–ï –ó–ù–ê–ß–ï–ù–ò–Ø
        if (np.isnan(z) or np.isinf(z) or 
            not isinstance(z, (int, float, np.number))):
            return None, None, None
            
        return float(z), current_spread, (mean, std)  # –Ø–≤–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ float

    def trading_signal_for_pair(self, z, is_stationary, pair_name):
        """–õ–æ–≥–∏–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –ø–∞—Ä—ã —Å ADF –ø—Ä–æ–≤–µ—Ä–∫–æ–π"""
        if z is None:
            return "NO DATA"
            
        if not is_stationary:
            return "NO TRADE - NOT STATIONARY"
            
        # R-–ø–æ—Ä–æ–≥–∏
        if z > 1.0:
            return f"SHORT_{pair_name.split('_')[0]}_LONG_{pair_name.split('_')[1]}"
        if z < -1.0:
            return f"LONG_{pair_name.split('_')[0]}_SHORT_{pair_name.split('_')[1]}"
        if abs(z) < 0.5:
            return "EXIT_POSITION"
            
        return "HOLD"

    def get_current_prices(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö —Ü–µ–Ω –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤"""
        try:
            # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –≥—Ä—É–ø–ø—ã –ø–æ 10 —Å–∏–º–≤–æ–ª–æ–≤ —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ª–∏–º–∏—Ç–æ–≤
            all_prices = {}
            for i in range(0, len(self.all_symbols), 10):
                symbols_batch = self.all_symbols[i:i+10]
                try:
                    tickers = self.exchange.fetch_tickers(symbols_batch)
                    
                    for symbol in symbols_batch:
                        if symbol in tickers and tickers[symbol].get("last") is not None:
                            all_prices[symbol] = tickers[symbol]["last"]
                        else:
                            logger.warning(f"‚ö†Ô∏è Missing price for {symbol}")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Batch price error: {e}")
                    # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –¥—Ä—É–≥–∏–º–∏ –±–∞—Ç—á–∞–º–∏
                
                time.sleep(0.2)  # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∑–∞–≥—Ä—É–∑–∏–ª–∏—Å—å –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Ü–µ–Ω—ã
            required_symbols = set()
            for pair in self.trading_pairs:
                required_symbols.add(pair["asset_a"])
                required_symbols.add(pair["asset_b"])
            
            missing_prices = required_symbols - set(all_prices.keys())
            if missing_prices:
                logger.warning(f"‚ö†Ô∏è Missing prices for: {missing_prices}")
                return None
                    
            return all_prices
        except Exception as e:
            logger.warning(f"‚ùå Error fetching prices: {e}")
            return None

    def run(self, interval_minutes=1):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –¥–ª—è –≤—Å–µ—Ö –ø–∞—Ä"""
        logger.info("üöÄ Starting R-STYLE PAIR MONITOR...")
        logger.info(f"üéØ Monitoring {len(self.trading_pairs)} trading pairs")
        logger.info(f"üéØ {len(self.all_symbols)} unique symbols")
        logger.info(f"üéØ ADF Lookbacks: {self.adf_lookbacks} bars")
        logger.info(f"üéØ Z-score Window: {self.window_bars} bars")
        logger.info(f"üéØ R-STYLE THRESHOLDS: ENTER ¬±1.0, EXIT ¬±0.5")
        
        logger.info("üî• PERFORMING COMPLETE DATA RESET BEFORE START...")
        if not self.complete_data_reset():
            logger.error("‚ùå CRITICAL: Complete data reset failed")
            return
            
        consecutive_bad_data = 0
        
        while True:
            try:
                prices = self.get_current_prices()
                if not prices:
                    consecutive_bad_data += 1
                    if consecutive_bad_data >= 3:
                        logger.error("üö® Too many consecutive price errors, restarting...")
                        self.complete_data_reset()
                        consecutive_bad_data = 0
                    time.sleep(60)
                    continue
                
                consecutive_bad_data = 0
                current_time = datetime.utcnow().strftime('%H:%M:%S')
                
                # üéØ –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –ö–ê–ñ–î–£–Æ –ü–ê–†–£ –ù–ï–ó–ê–í–ò–°–ò–ú–û
                all_pair_data = []
                active_pairs_count = 0
                trading_signals_count = 0
                
                for pair in self.trading_pairs:
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–∞—Ä—ã –±–µ–∑ –¥–∞–Ω–Ω—ã—Ö
                    if not self.pair_states[pair["name"]]['data_loaded']:
                        continue
                        
                    # –†–∞—Å—á–µ—Ç Z-score –∏ ADF –¥–ª—è –ø–∞—Ä—ã
                    z, spread, stats = self.calculate_zscore_for_pair(pair, prices)
                    historical_spread = self.get_pair_historical_spread(pair)
                    is_stationary = self.calculate_adf_test(historical_spread) if historical_spread is not None else False
                    
                    signal = self.trading_signal_for_pair(z, is_stationary, pair["name"])
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–∞—Ä—ã
                    self.pair_states[pair["name"]]['adf_passed'] = is_stationary
                    self.pair_states[pair["name"]]['current_signal'] = signal
                    
                    if is_stationary:
                        active_pairs_count += 1
                    if signal not in ["HOLD", "NO DATA", "NO TRADE - NOT STATIONARY"]:
                        trading_signals_count += 1
                    
                    # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–∞—Ä —Å –¥–∞–Ω–Ω—ã–º–∏ –∏ —Å–∏–≥–Ω–∞–ª–∞–º–∏
                    if z is not None and is_stationary:
                        adf_status = "STATIONARY"
                        status = "üö® ABNORMAL" if abs(z) > 3.0 else "‚úÖ NORMAL"
                        
                        if signal != "HOLD":
                            # üÜï –ë–ï–ó–û–ü–ê–°–ù–û–ï –§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ß–ê–°–¢–¨
                            try:
                                # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º z –≤ float –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                                z_float = float(z)
                                logger.info(f"[{current_time}] {pair['name']}: Z={z_float:.2f} {status} | {signal}")
                            except (ValueError, TypeError, Exception) as format_error:
                                # –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –æ—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤—ã–≤–æ–¥
                                logger.info(f"[{current_time}] {pair['name']}: Z={z} {status} | {signal}")
                    
                    # –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
                    pair_data = {
                        "pair_name": pair["name"],
                        "asset_a": pair["asset_a"],
                        "asset_b": pair["asset_b"], 
                        "price_a": prices.get(pair["asset_a"], 0),
                        "price_b": prices.get(pair["asset_b"], 0),
                        "spread": spread if spread else 0,
                        "z": z if z else 0,
                        "signal": signal,
                        "adf_passed": is_stationary
                    }
                    all_pair_data.append(pair_data)
                
                # –°–≤–æ–¥–∫–∞ –ø–æ –∏—Ç–µ—Ä–∞—Ü–∏–∏
                logger.info(f"üìä [{current_time}] Active: {active_pairs_count}/{len(self.trading_pairs)} | Signals: {trading_signals_count}")
                
                # –£–≤–µ–¥–æ–º–ª—è–µ–º –Ω–∞–±–ª—é–¥–∞—Ç–µ–ª–µ–π
                report_data = {
                    "time": datetime.utcnow(),
                    "pairs_data": all_pair_data,
                    "total_pairs": len(self.trading_pairs),
                    "active_pairs": active_pairs_count,
                    "trading_signals": trading_signals_count
                }
                
                # üÜï –°–û–•–†–ê–ù–Ø–ï–ú –¢–ï–ö–£–©–ò–ï –î–ê–ù–ù–´–ï –î–õ–Ø TELEGRAM
                self.current_report_data = report_data
                
                self.notify(report_data)
                
                time.sleep(interval_minutes * 60)
                
            except KeyboardInterrupt:
                logger.info("üõë Monitoring stopped by user")
                break
            except Exception as e:
                logger.warning(f"‚ùå Error in main loop: {e}")
                time.sleep(60)


def telegram_polling(trader, telegram_observer, monitor_instance):
    """
    –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è polling —Å –ø–µ—Ä–µ–¥–∞—á–µ–π —Ç–µ–∫—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö –º–æ–Ω–∏—Ç–æ—Ä–∞
    """
    TELEGRAM_BOT_TOKEN = "8436652130:AAF6On0GJtRHfMZyqD3mpM57eXZfWofJeng"
    offset = None
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"

    while True:
        try:
            params = {'timeout': 30, 'offset': offset}
            response = requests.get(url, params=params, timeout=35)
            updates = response.json().get("result", [])
            for update in updates:
                if "callback_query" in update:
                    data = update["callback_query"]["data"]
                    
                    # üÜï –ü–ï–†–ï–î–ê–ï–ú –¢–ï–ö–£–©–ò–ï –î–ê–ù–ù–´–ï –ú–û–ù–ò–¢–û–†–ê
                    current_data = None
                    if monitor_instance and hasattr(monitor_instance, 'current_report_data'):
                        current_data = monitor_instance.current_report_data
                    
                    handle_callback(data, trader, telegram_observer, current_data)
                offset = update["update_id"] + 1
            time.sleep(1)
        except Exception as e:
            print("Telegram polling error:", e)
            time.sleep(5)


def main():
    # üéØ –í–û–ó–ú–û–ñ–ù–û–°–¢–¨ –í–´–ë–û–†–ê –ü–†–ï–°–ï–¢–ê –ß–ï–†–ï–ó –ê–†–ì–£–ú–ï–ù–¢–´
    import argparse
    
    parser = argparse.ArgumentParser(description='R-Style Pair Trading Monitor')
    parser.add_argument('--preset', type=str, default='ultra_liquid_8', 
                       help='Pair preset: ultra_liquid_8, liquid_pairs_15, top_10_btc_pairs, auto_top_30')
    parser.add_argument('--test', action='store_true', help='Test pair configurations')
    
    args = parser.parse_args()
    
    if args.test:
        from pairs_config import get_all_presets
        print("üîç TESTING ALL PAIR PRESETS...")
        results = get_all_presets()
        
        for preset_name, pairs in results.items():
            print(f"\nüìä {preset_name.upper()}:")
            print(f"   Valid pairs: {len(pairs)}")
            if len(pairs) > 0:
                print(f"   Sample: {pairs[0]['name']} - {pairs[0]['asset_a']} / {pairs[0]['asset_b']}")
        sys.exit(0)
    
    # –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∞ —Å –≤—ã–±—Ä–∞–Ω–Ω—ã–º –ø—Ä–µ—Å–µ—Ç–æ–º
    monitor = RStylePairMonitor(pair_preset=args.preset)
    monitor.attach(ConsoleObserver())

    # üÜï –û–ë–ù–û–í–õ–ï–ù–ù–´–ô TRADER –° –ù–ê–ß–ê–õ–¨–ù–´–ú –ë–ê–õ–ê–ù–°–û–ú
    trader = OKXBasketTrader(paper_trading=True, max_exposure=1000, initial_balance=10000)
    monitor.attach(trader)

    telegram_observer = TelegramObserver(trader=trader)
    monitor.attach(telegram_observer)

    # üÜï –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –í–´–ó–û–í –° –ü–ï–†–ï–î–ê–ß–ï–ô –ú–û–ù–ò–¢–û–†–ê
    polling_thread = threading.Thread(
        target=telegram_polling, 
        args=(trader, telegram_observer, monitor),  # üÜï –ü–ï–†–ï–î–ê–ï–ú –ú–û–ù–ò–¢–û–†
        daemon=True
    )
    polling_thread.start()

    monitor.run(interval_minutes=1)


if __name__ == "__main__":
    main()

===== observer.py =====


class Observer:
    """Observer interface."""
    def update(self, data):
        raise NotImplementedError("Observer subclasses must implement 'update' method.")


class Subject:
    """Base class for observable objects."""
    def __init__(self):
        self._observers = []

    def attach(self, observer: Observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def detach(self, observer: Observer):
        if observer in self._observers:
            self._observers.remove(observer)

    def notify(self, data=None):
        for observer in self._observers:
            observer.update(data)


===== pairs_config.py =====


#!/usr/bin/env python3
"""
–ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –¢–û–†–ì–û–í–´–• –ü–ê–† - –¢–û–õ–¨–ö–û –õ–ò–ö–í–ò–î–ù–´–ï –ò –ü–†–û–í–ï–†–ï–ù–ù–´–ï –ü–ê–†–´
"""

import ccxt
import json
from typing import List, Dict
import time

def get_top_symbols_from_exchange(limit=30):
    """–ü–æ–ª—É—á–∞–µ—Ç –¢–û–õ–¨–ö–û –ª–∏–∫–≤–∏–¥–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã —Å OKX"""
    try:
        # –ñ–µ—Å—Ç–∫–æ –∑–∞–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –ª–∏–∫–≤–∏–¥–Ω—ã—Ö –ø–∞—Ä (—Ç–æ–ø-20 –ø–æ –æ–±—ä–µ–º—É)
        liquid_symbols = [
            "BTC/USDT:USDT", "ETH/USDT:USDT", "BNB/USDT:USDT", "SOL/USDT:USDT",
            "XRP/USDT:USDT", "ADA/USDT:USDT", "AVAX/USDT:USDT", "DOT/USDT:USDT",
            "LINK/USDT:USDT", "LTC/USDT:USDT", "ATOM/USDT:USDT", "DOGE/USDT:USDT",
            "MATIC/USDT:USDT", "TRX/USDT:USDT", "XLM/USDT:USDT", "BCH/USDT:USDT",
            "FIL/USDT:USDT", "ETC/USDT:USDT", "EOS/USDT:USDT", "AAVE/USDT:USDT"
        ]
        
        print(f"‚úÖ Using {len(liquid_symbols)} LIQUID symbols")
        print("üìã Liquid symbols:", liquid_symbols[:10])
        
        return liquid_symbols[:limit]
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        return get_fallback_symbols()[:limit]

def get_fallback_symbols():
    """–†–µ–∑–µ—Ä–≤–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å –±–∏—Ä–∂–∏"""
    return [
        "BTC/USDT:USDT", "ETH/USDT:USDT", "BNB/USDT:USDT", "SOL/USDT:USDT",
        "XRP/USDT:USDT", "ADA/USDT:USDT", "AVAX/USDT:USDT", "DOT/USDT:USDT",
        "LINK/USDT:USDT", "LTC/USDT:USDT", "ATOM/USDT:USDT", "TRX/USDT:USDT",
        "XLM/USDT:USDT", "BCH/USDT:USDT", "FIL/USDT:USDT", "ETC/USDT:USDT",
        "EOS/USDT:USDT", "AAVE/USDT:USDT", "ALGO/USDT:USDT", "XTZ/USDT:USDT"
    ]

def generate_top_30_pairs(symbols: List[str]):
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–æ–ø-30 —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä"""
    pairs = []
    
    if not symbols:
        symbols = get_fallback_symbols()
    
    # –£–±–µ–¥–∏–º—Å—è —á—Ç–æ BTC –∏ ETH –µ—Å—Ç—å –≤ —Å–ø–∏—Å–∫–µ
    essential_symbols = ["BTC/USDT:USDT", "ETH/USDT:USDT"]
    for essential in essential_symbols:
        if essential not in symbols:
            symbols.insert(0, essential)
    
    # 1. BTC –ø–∞—Ä—ã —Å —Ç–æ–ø-10 –∞–ª—å—Ç–∞–º–∏ (–∫—Ä–æ–º–µ —Å–µ–±—è)
    btc_symbol = "BTC/USDT:USDT"
    btc_counter = 0
    for symbol in symbols:
        if symbol != btc_symbol and btc_counter < 10:
            alt_name = symbol.split('/')[0]
            pairs.append({
                "asset_a": btc_symbol,
                "asset_b": symbol,
                "name": f"BTC_{alt_name}",
                "type": "btc_pair"
            })
            btc_counter += 1
    
    # 2. ETH –ø–∞—Ä—ã —Å —Ç–æ–ø-8 –∞–ª—å—Ç–∞–º–∏ (–∫—Ä–æ–º–µ BTC –∏ —Å–µ–±—è)
    eth_symbol = "ETH/USDT:USDT"
    eth_counter = 0
    for symbol in symbols:
        if (symbol != eth_symbol and 
            symbol != btc_symbol and 
            not symbol.startswith('BTC/') and 
            eth_counter < 8):
            alt_name = symbol.split('/')[0]
            pairs.append({
                "asset_a": eth_symbol,
                "asset_b": symbol,
                "name": f"ETH_{alt_name}",
                "type": "eth_pair"
            })
            eth_counter += 1
    
    # 3. –ü–∞—Ä—ã –º–µ–∂–¥—É —Ç–æ–ø-12 –∞–ª—å—Ç–∞–º–∏ (–∏—Å–∫–ª—é—á–∞—è BTC/ETH)
    alt_symbols = [s for s in symbols if not s.startswith('BTC/') and not s.startswith('ETH/')][:12]
    alt_pairs_added = 0
    
    for i in range(len(alt_symbols)):
        for j in range(i + 1, len(alt_symbols)):
            if alt_pairs_added >= 12:  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
                break
                
            asset_a = alt_symbols[i]
            asset_b = alt_symbols[j]
            name_a = asset_a.split('/')[0]
            name_b = asset_b.split('/')[0]
            
            pairs.append({
                "asset_a": asset_a,
                "asset_b": asset_b,
                "name": f"{name_a}_{name_b}",
                "type": "alt_pair"
            })
            alt_pairs_added += 1
        
        if alt_pairs_added >= 12:
            break
    
    # –û–±—Ä–µ–∑–∞–µ–º –¥–æ 30 –ø–∞—Ä –µ—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–æ—Å—å –±–æ–ª—å—à–µ
    pairs = pairs[:30]
    
    print(f"‚úÖ Generated {len(pairs)} trading pairs:")
    print(f"   - {btc_counter} BTC pairs")
    print(f"   - {eth_counter} ETH pairs") 
    print(f"   - {alt_pairs_added} ALT pairs")
    
    return pairs

def get_current_top_30_pairs():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–∏–µ —Ç–æ–ø-30 –ø–∞—Ä"""
    top_symbols = get_top_symbols_from_exchange(35)  # –ë–µ—Ä–µ–º –Ω–µ–º–Ω–æ–≥–æ –±–æ–ª—å—à–µ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
    return generate_top_30_pairs(top_symbols)

# üéØ –ü–†–ï–°–ï–¢–´ (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ + —Ä—É—á–Ω—ã–µ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
def get_all_presets():
    """–í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø—Ä–µ—Å–µ—Ç—ã"""
    auto_pairs = get_current_top_30_pairs()
    
    # –ù–æ–≤—ã–π –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–π –ø—Ä–µ—Å–µ—Ç —Å –ª–∏–∫–≤–∏–¥–Ω—ã–º–∏ –ø–∞—Ä–∞–º–∏
    liquid_pairs = [
        {"asset_a": "BTC/USDT:USDT", "asset_b": "ETH/USDT:USDT", "name": "BTC_ETH"},
        {"asset_a": "BTC/USDT:USDT", "asset_b": "BNB/USDT:USDT", "name": "BTC_BNB"},
        {"asset_a": "BTC/USDT:USDT", "asset_b": "SOL/USDT:USDT", "name": "BTC_SOL"},
        {"asset_a": "BTC/USDT:USDT", "asset_b": "XRP/USDT:USDT", "name": "BTC_XRP"},
        {"asset_a": "BTC/USDT:USDT", "asset_b": "ADA/USDT:USDT", "name": "BTC_ADA"},
        {"asset_a": "ETH/USDT:USDT", "asset_b": "BNB/USDT:USDT", "name": "ETH_BNB"},
        {"asset_a": "ETH/USDT:USDT", "asset_b": "SOL/USDT:USDT", "name": "ETH_SOL"},
        {"asset_a": "ETH/USDT:USDT", "asset_b": "ADA/USDT:USDT", "name": "ETH_ADA"},
        {"asset_a": "BNB/USDT:USDT", "asset_b": "SOL/USDT:USDT", "name": "BNB_SOL"},
        {"asset_a": "XRP/USDT:USDT", "asset_b": "ADA/USDT:USDT", "name": "XRP_ADA"},
        {"asset_a": "BTC/USDT:USDT", "asset_b": "LTC/USDT:USDT", "name": "BTC_LTC"},
        {"asset_a": "ETH/USDT:USDT", "asset_b": "LTC/USDT:USDT", "name": "ETH_LTC"},
        {"asset_a": "BTC/USDT:USDT", "asset_b": "LINK/USDT:USDT", "name": "BTC_LINK"},
        {"asset_a": "ETH/USDT:USDT", "asset_b": "LINK/USDT:USDT", "name": "ETH_LINK"},
        {"asset_a": "BTC/USDT:USDT", "asset_b": "AVAX/USDT:USDT", "name": "BTC_AVAX"},
    ]
    
    return {
        # üöÄ –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ï –ü–†–ï–°–ï–¢–´
        "auto_top_30": auto_pairs,
        "auto_top_20": auto_pairs[:20],
        "auto_top_15": auto_pairs[:15],
        "auto_btc_focused": [p for p in auto_pairs if p["asset_a"] == "BTC/USDT:USDT"][:15],
        
        # üìã –†–£–ß–ù–´–ï –ü–†–ï–°–ï–¢–´ (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
        "top_10_btc_pairs": [
            {"asset_a": "BTC/USDT:USDT", "asset_b": "ETH/USDT:USDT", "name": "BTC_ETH"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "BNB/USDT:USDT", "name": "BTC_BNB"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "SOL/USDT:USDT", "name": "BTC_SOL"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "XRP/USDT:USDT", "name": "BTC_XRP"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "ADA/USDT:USDT", "name": "BTC_ADA"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "AVAX/USDT:USDT", "name": "BTC_AVAX"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "DOT/USDT:USDT", "name": "BTC_DOT"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "LINK/USDT:USDT", "name": "BTC_LINK"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "LTC/USDT:USDT", "name": "BTC_LTC"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "ATOM/USDT:USDT", "name": "BTC_ATOM"},
        ],
        
        # üéØ –ù–û–í–´–ô –ü–†–û–í–ï–†–ï–ù–ù–´–ô –ü–†–ï–°–ï–¢
        "liquid_pairs_15": liquid_pairs,
        
        # üî• –£–õ–¨–¢–†–ê-–õ–ò–ö–í–ò–î–ù–´–ï –ü–ê–†–´ (—Ç–æ–ø-8)
        "ultra_liquid_8": [
            {"asset_a": "BTC/USDT:USDT", "asset_b": "ETH/USDT:USDT", "name": "BTC_ETH"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "BNB/USDT:USDT", "name": "BTC_BNB"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "SOL/USDT:USDT", "name": "BTC_SOL"},
            {"asset_a": "ETH/USDT:USDT", "asset_b": "BNB/USDT:USDT", "name": "ETH_BNB"},
            {"asset_a": "ETH/USDT:USDT", "asset_b": "SOL/USDT:USDT", "name": "ETH_SOL"},
            {"asset_a": "BNB/USDT:USDT", "asset_b": "SOL/USDT:USDT", "name": "BNB_SOL"},
            {"asset_a": "BTC/USDT:USDT", "asset_b": "ADA/USDT:USDT", "name": "BTC_ADA"},
            {"asset_a": "ETH/USDT:USDT", "asset_b": "ADA/USDT:USDT", "name": "ETH_ADA"},
        ]
    }

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
PAIR_PRESETS = get_all_presets()
AVAILABLE_SYMBOLS = get_top_symbols_from_exchange(30) or get_fallback_symbols()

def get_preset(preset_name):
    """–ü–æ–ª—É—á–∏—Ç—å –ø—Ä–µ—Å–µ—Ç –ø–æ –∏–º–µ–Ω–∏"""
    all_presets = get_all_presets()
    return all_presets.get(preset_name, [])

def list_available_presets():
    """–°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–µ—Å–µ—Ç–æ–≤"""
    return list(get_all_presets().keys())

def refresh_presets():
    """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ—Å–µ—Ç–æ–≤ —Å –±–∏—Ä–∂–∏"""
    global PAIR_PRESETS, AVAILABLE_SYMBOLS
    PAIR_PRESETS = get_all_presets()
    AVAILABLE_SYMBOLS = get_top_symbols_from_exchange(30) or get_fallback_symbols()
    return PAIR_PRESETS

def test_pair_combinations():
    """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç –≤—Å–µ –ø—Ä–µ—Å–µ—Ç—ã –ø–∞—Ä –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã"""
    print("üîç TESTING ALL PAIR PRESETS...")
    results = {}
    
    all_presets = get_all_presets()
    
    for preset_name, pairs in all_presets.items():
        valid_pairs = 0
        total_pairs = len(pairs)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é –ø–∞—Ä—É –Ω–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å
        for pair in pairs:
            if (pair.get('asset_a') and 
                pair.get('asset_b') and 
                pair.get('name')):
                valid_pairs += 1
        
        results[preset_name] = {
            'valid': valid_pairs,
            'total': total_pairs,
            'pairs': pairs
        }
        
        print(f"üìä {preset_name.upper()}:")
        print(f"   Valid pairs: {valid_pairs}/{total_pairs}")
        if valid_pairs > 0:
            print(f"   Sample: {pairs[0]['name']} - {pairs[0]['asset_a']} / {pairs[0]['asset_b']}")
    
    return results

if __name__ == "__main__":
    print("üîç TESTING ALL PRESETS...")
    presets = get_all_presets()
    
    for name, pairs in presets.items():
        print(f"\nüéØ {name.upper()} ({len(pairs)} pairs):")
        for pair in pairs[:3]:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 3 –ø–∞—Ä—ã
            print(f"   {pair['name']}: {pair['asset_a']} / {pair['asset_b']}")
        if len(pairs) > 3:
            print(f"   ... and {len(pairs) - 3} more pairs")

===== reset_data.py =====


#!/usr/bin/env python3
"""
–°–ö–†–ò–ü–¢ –î–õ–Ø –ü–û–õ–ù–û–ì–û –°–ë–†–û–°–ê –ò –ü–ï–†–ï–ó–ê–ì–†–£–ó–ö–ò –î–ê–ù–ù–´–•
"""

import sys
import os
import logging

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from monitor import RStylePairMonitor  # üÜï –ò–ú–ü–û–†–¢–ò–†–£–ï–ú –ù–û–í–´–ô –ö–õ–ê–°–°

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

def main():
    print("=" * 60)
    print("üîÑ DATA RESET SCRIPT - COMPLETE HISTORICAL DATA RELOAD")
    print("=" * 60)
    
    try:
        monitor = RStylePairMonitor()  # üÜï –°–û–ó–î–ê–ï–ú –ù–û–í–´–ô –ú–û–ù–ò–¢–û–†
        print("üìä Starting complete data reset...")
        
        if monitor.complete_data_reset():
            print("‚úÖ SUCCESS: Data reset completed successfully!")
            print("üéØ You can now run: python monitor.py")
            print("")
            print("üìà R-STYLE PAIR TRADING READY:")
            print("   - 4 trading pairs (1vs1)")
            print("   - ADF tests on 120/90/60 bars") 
            print("   - Z-score on 35-bar sliding window")
        else:
            print("‚ùå FAILED: Data reset failed!")
            
    except Exception as e:
        print(f"üí• ERROR: {e}")
    
    print("=" * 60)

if __name__ == "__main__":
    main()

===== telegram_observer.py =====


from observer import Observer
import json
import requests
from callback_handler import handle_callback
from datetime import datetime

TELEGRAM_BOT_TOKEN = "8436652130:AAF6On0GJtRHfMZyqD3mpM57eXZfWofJeng"
TELEGRAM_CHAT_ID = 317217451

class TelegramObserver(Observer):
    def __init__(self, trader=None):
        self.token = TELEGRAM_BOT_TOKEN
        self.chat_id = TELEGRAM_CHAT_ID
        self.trader = trader
        self.last_signals = {}
        self.last_zs = {}
        self.last_status_message = None

    def send_message(self, text, buttons=None):
        url = f"https://api.telegram.org/bot{self.token}/sendMessage"
        payload = {
            'chat_id': self.chat_id,
            'text': text,
            'parse_mode': 'HTML'
        }
        if buttons:
            payload['reply_markup'] = json.dumps({'inline_keyboard': buttons})
        try:
            requests.post(url, data=payload, timeout=10)
        except Exception as e:
            print("Telegram send failed:", e)

    def update(self, data):
        pairs_data = data.get('pairs_data', [])
        
        current_time = datetime.now()
        if (not self.last_status_message or 
            (current_time - self.last_status_message).total_seconds() > 600):
            
            self.send_detailed_status(self.trader, data)
            self.last_status_message = current_time
        
        messages_to_send = []
        
        for pair_data in pairs_data:
            pair_name = pair_data['pair_name']
            current_signal = pair_data.get('signal', '')
            current_z = pair_data.get('z', 0)
            adf_passed = pair_data.get('adf_passed', False)
            
            if pair_name not in self.last_signals:
                self.last_signals[pair_name] = ''
                self.last_zs[pair_name] = 0
            
            should_send = False
            
            if (current_signal != self.last_signals[pair_name] and 
                current_signal not in ["HOLD", "NO DATA", "NO TRADE - NOT STATIONARY"]):
                should_send = True
            elif (adf_passed and 
                  abs(current_z - self.last_zs[pair_name]) > 0.2 and
                  current_signal not in ["HOLD", "NO DATA"]):
                should_send = True
            elif (self.last_signals[pair_name] == '' and 
                  current_signal not in ["HOLD", "NO DATA", "NO TRADE - NOT STATIONARY"]):
                should_send = True
            
            if should_send:
                asset_a = pair_data['asset_a'].split('/')[0]
                asset_b = pair_data['asset_b'].split('/')[0]
                
                z_score = round(current_z, 2)
                price_a = round(pair_data.get('price_a', 0), 2)
                price_b = round(pair_data.get('price_b', 0), 2)
                
                formatted_signal = current_signal
                if "SHORT_" in current_signal and "LONG_" in current_signal:
                    parts = current_signal.split('_')
                    if len(parts) >= 4:
                        formatted_signal = f"SHORT {parts[1]} / LONG {parts[3]}"
                
                msg = (
                    f"üéØ <b>TRADING SIGNAL - {pair_name}</b>\n"
                    f"Signal: <b>{formatted_signal}</b>\n"
                    f"Z-score: {z_score}\n"
                    f"ADF Test: {'‚úÖ PASSED' if adf_passed else '‚ùå FAILED'}\n"
                    f"Prices: {asset_a}={price_a} | {asset_b}={price_b}"
                )
                
                messages_to_send.append({
                    'message': msg,
                    'signal': current_signal,
                    'pair_name': pair_name
                })
            
            self.last_signals[pair_name] = current_signal
            self.last_zs[pair_name] = current_z
        
        for msg_data in messages_to_send:
            buttons = None
            signal = msg_data['signal']
            pair_name = msg_data['pair_name']
            
            if signal and signal not in ["HOLD", "NO DATA", "NO TRADE - NOT STATIONARY", "EXIT_POSITION"]:
                buttons = [
                    [
                        {'text': 'üìà OPEN', 'callback_data': f'OPEN:{signal}:{pair_name}'},
                        {'text': 'üìâ CLOSE', 'callback_data': f'CLOSE:{signal}:{pair_name}'}
                    ]
                ]
            elif signal == "EXIT_POSITION":
                buttons = [
                    [
                        {'text': 'üî¥ CLOSE POSITION', 'callback_data': f'CLOSE:{signal}:{pair_name}'}
                    ]
                ]
            
            self.send_message(msg_data['message'], buttons)

    def send_detailed_status(self, trader, data=None):
        """–î–µ—Ç–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å —Å —Ç–µ–∫—É—â–∏–º–∏ Z-score"""
        summary = trader.get_trading_summary(data)
        
        main_msg = (
            f"üìà <b>TRADING SUMMARY</b>\n"
            f"Initial: ${summary['initial_balance']:.2f}\n"
            f"Equity: ${summary['total_equity']:.2f}\n"
            f"Closed PnL: ${summary['total_pnl']:.2f}\n"
            f"Floating PnL: ${summary['floating_pnl']:.2f}\n"
            f"Trades: {summary['total_trades']}\n"
            f"Open: {summary['open_positions']}\n"
            f"Win Rate: {summary['win_rate']:.1f}%\n"
            f"Drawdown: {summary['max_drawdown']:.1f}%\n"
        )
        
        positions_msg = ""
        if 'open_positions_details' in summary and summary['open_positions_details']:
            positions_msg = "\n\nüéØ <b>OPEN POSITIONS:</b>\n"
            for pos in summary['open_positions_details']:
                entry_z = pos['entry_z']
                current_z = pos['current_z']
                
                if current_z is not None:
                    if abs(current_z) < abs(entry_z):
                        trend = "üìâ –∫ –≤—ã—Ö–æ–¥—É"
                        trend_arrow = "üü¢"
                    else:
                        trend = "üìà –æ—Ç –≤—ã—Ö–æ–¥–∞" 
                        trend_arrow = "üî¥"
                    z_change = current_z - entry_z
                else:
                    trend = "üìä –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
                    trend_arrow = "‚ö™"
                    z_change = 0
                
                positions_msg += (
                    f"{trend_arrow} <b>{pos['pair']}</b>\n"
                    f"   Signal: {pos['signal']}\n"
                    f"   Entry Z: {entry_z:.2f}\n"
                    f"   Current Z: {current_z:.2f if current_z is not None else 'N/A'}\n"
                    f"   Change: {z_change:+.2f} {trend}\n"
                    f"   PnL: ${pos['floating_pnl']:+.2f}\n"
                    f"   Size: ${pos['size']:.2f}\n"
                    f"   Duration: {pos['duration_minutes']} min\n"
                    f"   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
                )
        else:
            positions_msg = "\n\nüìã <b>No open positions</b>"
        
        legend_msg = (
            "\n\nüìä <b>LEGEND:</b>\n"
            "üü¢ Z-score ‚Üí 0 (—Ö–æ—Ä–æ—à–æ)\n"
            "üî¥ Z-score ‚Üê 0 (–ø–ª–æ—Ö–æ)\n"
            "üéØ –í—Ö–æ–¥: |Z| > 1.0, –í—ã—Ö–æ–¥: |Z| < 0.5"
        )
        
        buttons = [
            [
                {'text': 'üìä Summary', 'callback_data': 'SUMMARY'},
                {'text': 'üõë Close All', 'callback_data': 'CLOSE_ALL'}
            ],
            [
                {'text': '‚úÖ Enable Auto', 'callback_data': 'ENABLE_AUTO'},
                {'text': 'üö´ Disable Auto', 'callback_data': 'DISABLE_AUTO'},
                {'text': 'üíæ Export Log', 'callback_data': 'EXPORT_LOG'}
            ]
        ]
        
        full_msg = main_msg + positions_msg + legend_msg
        self.send_message(full_msg, buttons)

    def handle_management_callback(self, callback_data, trader, current_data=None):
        if callback_data == 'SUMMARY':
            self.send_detailed_status(trader, current_data)
        elif callback_data == 'CLOSE_ALL':
            closed_count = trader.close_all_positions()
            self.send_message(f"‚úÖ Closed {closed_count} positions")
        elif callback_data == 'ENABLE_AUTO':
            trader.enable_trading()
            self.send_message("‚úÖ Auto trading ENABLED")
        elif callback_data == 'DISABLE_AUTO':
            trader.disable_trading()
            self.send_message("üö´ Auto trading DISABLED")
        elif callback_data == 'EXPORT_LOG':
            if trader.export_trading_log():
                self.send_message("‚úÖ Trading log exported")
            else:
                self.send_message("‚ùå Failed to export log")

===== test_connection.py =====


#!/usr/bin/env python3
import ccxt
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def test_okx_connection():
    print("üîç Testing OKX connection...")
    
    try:
        exchange = ccxt.okx({
            "enableRateLimit": True,
            "options": {"defaultType": "swap"},
            "sandbox": False
        })
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä—ã–Ω–∫–∏
        print("üìä Loading markets...")
        markets = exchange.load_markets()
        print(f"‚úÖ Loaded {len(markets)} markets")
        
        # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å —Ç–∏–∫–µ—Ä—ã –¥–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø–∞—Ä
        test_symbols = ["BTC/USDT:USDT", "ETH/USDT:USDT", "BNB/USDT:USDT"]
        print("üìà Testing price data...")
        
        for symbol in test_symbols:
            try:
                ticker = exchange.fetch_ticker(symbol)
                print(f"‚úÖ {symbol}: {ticker['last']}")
            except Exception as e:
                print(f"‚ùå {symbol}: {e}")
                
        # –¢–µ—Å—Ç–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
        print("üìä Testing historical data...")
        ohlcv = exchange.fetch_ohlcv("BTC/USDT:USDT", "15m", limit=10)
        print(f"‚úÖ BTC Historical data: {len(ohlcv)} bars")
        
    except Exception as e:
        print(f"‚ùå Connection failed: {e}")

if __name__ == "__main__":
    test_okx_connection()

===== trader.py =====


from observer import Observer
import logging
from datetime import datetime
import json
import pandas as pd
import numpy as np

logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger(__name__)

class OKXBasketTrader(Observer):
    def __init__(self, paper_trading=True, max_exposure=1000, initial_balance=10000):
        self.paper_trading = paper_trading
        self.max_exposure = max_exposure
        self.initial_balance = initial_balance
        self.current_balance = initial_balance
        self.current_positions = {}
        self.position_history = []
        self.trading_enabled = True
        self.peak_equity = initial_balance
        
        self.performance_stats = {
            'total_trades': 0,
            'winning_trades': 0,
            'losing_trades': 0,
            'total_pnl': 0,
            'max_drawdown': 0,
            'current_drawdown': 0,
            'best_trade': 0,
            'worst_trade': 0,
            'avg_trade_duration': 0
        }

    def update(self, data):
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ç–æ—Ä–≥–æ–≤–ª—è –ø–æ —Å–∏–≥–Ω–∞–ª–∞–º"""
        if not self.trading_enabled:
            return
            
        pairs_data = data.get('pairs_data', [])
        current_time = datetime.now()
        
        for pair_data in pairs_data:
            signal = pair_data.get("signal")
            pair_name = pair_data.get("pair_name")
            z_score = pair_data.get("z", 0)
            current_prices = {
                pair_data['asset_a']: pair_data.get('price_a', 0),
                pair_data['asset_b']: pair_data.get('price_b', 0)
            }
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–ª–∞–≤–∞—é—â–∏–π PnL –¥–ª—è –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π
            if pair_name in self.current_positions:
                self.update_floating_pnl(pair_name, current_prices, current_time)
            
            # –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –ó–ê–ö–†–´–¢–ò–ï
            if signal == "EXIT_POSITION" and pair_name in self.current_positions:
                self.close_position(signal, pair_name, f"Auto-close on exit signal (Z={z_score:.2f})", current_prices)
            
            # –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –û–¢–ö–†–´–¢–ò–ï
            elif (signal and 
                  signal not in ["HOLD", "NO DATA", "NO TRADE - NOT STATIONARY", "EXIT_POSITION"] and
                  pair_name not in self.current_positions and
                  pair_data.get('adf_passed', False)):
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç—ã —ç–∫—Å–ø–æ–∑–∏—Ü–∏–∏
                if self.get_total_exposure() < self.max_exposure * 0.8:
                    self.open_position(signal, pair_name, z_score=z_score, current_prices=current_prices)

    def open_position(self, signal: str, pair_name: str, size=None, z_score=0, current_prices=None):
        """–û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ —Å –ø–æ–ª–Ω—ã–º —Ç—Ä–µ–∫–∏–Ω–≥–æ–º"""
        if size is None:
            size = min(self.max_exposure / 4, self.current_balance * 0.2)
        
        if pair_name in self.current_positions:
            logger.warning(f"‚ö†Ô∏è [PAPER] Position already open for {pair_name}")
            return False
        
        position = {
            'signal': signal,
            'size': size,
            'pair_name': pair_name,
            'entry_time': datetime.now(),
            'entry_z': z_score,
            'entry_prices': current_prices.copy() if current_prices else {},
            'current_prices': current_prices.copy() if current_prices else {},
            'floating_pnl': 0,
            'status': 'OPEN',
            'type': 'MANUAL' if 'MANUAL' in signal else 'AUTO',
            'max_floating_pnl': 0,
            'min_floating_pnl': 0
        }
        
        self.current_positions[pair_name] = position
        self.current_balance -= size

        trade_record = {
            'action': 'OPEN',
            'pair_name': pair_name,
            'signal': signal,
            'size': size,
            'entry_time': position['entry_time'],
            'entry_z': z_score,
            'type': position['type'],
            'timestamp': datetime.now().isoformat()
        }
        self.position_history.append(trade_record)
        
        logger.info(f"‚úÖ [PAPER] OPENED: {pair_name} - {signal} | Size: ${size:.2f} | Z: {z_score:.2f}")
        return True

    def close_position(self, signal: str, pair_name: str, reason="Manual close", current_prices=None):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ —Å —Ä–∞—Å—á–µ—Ç–æ–º PnL"""
        if pair_name not in self.current_positions:
            logger.warning(f"‚ö†Ô∏è [PAPER] No open position to close for {pair_name}")
            return False
        
        position = self.current_positions[pair_name]
        pnl = position['floating_pnl']
        self.current_balance += position['size'] + pnl
        
        close_record = {
            'action': 'CLOSE',
            'pair_name': pair_name,
            'original_signal': position['signal'],
            'close_signal': signal,
            'size': position['size'],
            'pnl': pnl,
            'pnl_percent': (pnl / position['size']) * 100 if position['size'] > 0 else 0,
            'entry_time': position['entry_time'],
            'exit_time': datetime.now(),
            'entry_z': position['entry_z'],
            'exit_reason': reason,
            'duration_minutes': round((datetime.now() - position['entry_time']).total_seconds() / 60, 1),
            'timestamp': datetime.now().isoformat()
        }
        
        self.position_history.append(close_record)
        self.update_performance_stats(close_record)
        del self.current_positions[pair_name]
        
        logger.info(f"‚úÖ [PAPER] CLOSED: {pair_name} | PnL: ${pnl:.2f} | Reason: {reason}")
        return True

    def update_floating_pnl(self, pair_name: str, current_prices: dict, current_time: datetime):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–ª–∞–≤–∞—é—â–µ–≥–æ PnL"""
        if pair_name not in self.current_positions:
            return
        
        position = self.current_positions[pair_name]
        position['current_prices'] = current_prices.copy()
        
        current_z = self.estimate_current_z(position, current_prices)
        if current_z is not None:
            z_distance_from_entry = abs(position['entry_z']) - abs(current_z)
            pnl = position['size'] * z_distance_from_entry * 0.05
            
            position['floating_pnl'] = pnl
            position['max_floating_pnl'] = max(position['max_floating_pnl'], pnl)
            position['min_floating_pnl'] = min(position['min_floating_pnl'], pnl)

    def estimate_current_z(self, position: dict, current_prices: dict) -> float:
        """–û—Ü–µ–Ω–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ Z-score"""
        try:
            entry_prices = position['entry_prices']
            signal = position['signal']
            
            if "SHORT_" in signal and "LONG_" in signal:
                parts = signal.split('_')
                short_asset = parts[1] + "/USDT:USDT"
                long_asset = parts[3] + "/USDT:USDT"
                
                if short_asset in entry_prices and long_asset in entry_prices:
                    entry_short = entry_prices[short_asset]
                    entry_long = entry_prices[long_asset]
                    current_short = current_prices.get(short_asset, entry_short)
                    current_long = current_prices.get(long_asset, entry_long)
                    
                    entry_spread = entry_short / entry_long
                    current_spread = current_short / current_long
                    spread_change_pct = (current_spread - entry_spread) / entry_spread * 100
                    
                    if "SHORT" in signal.split('_')[0]:
                        return position['entry_z'] - abs(spread_change_pct) * 0.1
                    else:
                        return position['entry_z'] + abs(spread_change_pct) * 0.1
        except Exception as e:
            logger.warning(f"Error estimating Z-score: {e}")
        
        return position['entry_z'] * 0.95

    def update_performance_stats(self, close_record: dict):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        self.performance_stats['total_trades'] += 1
        pnl = close_record['pnl']
        self.performance_stats['total_pnl'] += pnl
        
        if pnl > 0:
            self.performance_stats['winning_trades'] += 1
            self.performance_stats['best_trade'] = max(self.performance_stats['best_trade'], pnl)
        elif pnl < 0:
            self.performance_stats['losing_trades'] += 1
            self.performance_stats['worst_trade'] = min(self.performance_stats['worst_trade'], pnl)
        
        closed_trades = [h for h in self.position_history if h['action'] == 'CLOSE']
        if closed_trades:
            durations = [trade['duration_minutes'] for trade in closed_trades]
            self.performance_stats['avg_trade_duration'] = sum(durations) / len(durations)

    def update_drawdown(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Å–∞–¥–∫–∏"""
        current_equity = self.get_total_equity()
        self.peak_equity = max(self.peak_equity, current_equity)
        
        if self.peak_equity > 0:
            drawdown = (self.peak_equity - current_equity) / self.peak_equity * 100
            self.performance_stats['current_drawdown'] = drawdown
            self.performance_stats['max_drawdown'] = max(self.performance_stats['max_drawdown'], drawdown)

    def get_total_exposure(self) -> float:
        return sum(pos['size'] for pos in self.current_positions.values())

    def get_total_floating_pnl(self) -> float:
        return sum(pos['floating_pnl'] for pos in self.current_positions.values())

    def get_total_equity(self) -> float:
        return self.current_balance + self.get_total_floating_pnl()

    def get_trading_summary(self, current_prices_data=None):
        """–°–≤–æ–¥–∫–∞ —Å —Ç–µ–∫—É—â–∏–º–∏ Z-score"""
        self.update_drawdown()
        
        closed_trades = [h for h in self.position_history if h['action'] == 'CLOSE']
        total_closed_pnl = sum(trade.get('pnl', 0) for trade in closed_trades)
        
        win_rate = 0
        if self.performance_stats['total_trades'] > 0:
            win_rate = (self.performance_stats['winning_trades'] / self.performance_stats['total_trades']) * 100
        
        open_positions_details = []
        for pair_name, position in self.current_positions.items():
            current_z = None
            if current_prices_data:
                for pair_data in current_prices_data.get('pairs_data', []):
                    if pair_data.get('pair_name') == pair_name:
                        current_z = pair_data.get('z')
                        break
            
            if current_z is None:
                current_z = self.estimate_current_z(position, position.get('current_prices', {}))
            
            open_positions_details.append({
                'pair': pair_name,
                'signal': position['signal'],
                'size': position['size'],
                'entry_z': position['entry_z'],
                'current_z': current_z,
                'floating_pnl': position['floating_pnl'],
                'duration_minutes': round((datetime.now() - position['entry_time']).total_seconds() / 60, 1),
                'type': position['type']
            })
    
        return {
            'initial_balance': self.initial_balance,
            'current_balance': self.current_balance,
            'total_equity': self.get_total_equity(),
            'total_pnl': total_closed_pnl,
            'floating_pnl': self.get_total_floating_pnl(),
            'total_trades': self.performance_stats['total_trades'],
            'open_positions': len(self.current_positions),
            'open_positions_details': open_positions_details,
            'win_rate': win_rate,
            'max_drawdown': self.performance_stats['max_drawdown'],
            'current_drawdown': self.performance_stats['current_drawdown'],
            'best_trade': self.performance_stats['best_trade'],
            'worst_trade': self.performance_stats['worst_trade'],
            'avg_duration': self.performance_stats['avg_trade_duration'],
            'current_positions': list(self.current_positions.keys())
        }

    def get_open_positions(self):
        return self.current_positions

    def get_position_history(self, limit=10):
        return self.position_history[-limit:] if self.position_history else []

    def export_trading_log(self, filename=None):
        if not filename:
            filename = f"trading_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        log_data = {
            'export_time': datetime.now().isoformat(),
            'summary': self.get_trading_summary(),
            'performance_stats': self.performance_stats,
            'position_history': self.position_history,
            'current_positions': self.current_positions
        }
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(log_data, f, indent=2, default=str)
            logger.info(f"‚úÖ Trading log exported to {filename}")
            return True
        except Exception as e:
            logger.error(f"‚ùå Error exporting log: {e}")
            return False

    def enable_trading(self):
        self.trading_enabled = True
        logger.info("‚úÖ AUTO TRADING ENABLED")

    def disable_trading(self):
        self.trading_enabled = False
        logger.info("üö´ AUTO TRADING DISABLED")

    def close_all_positions(self, reason="Manual close all"):
        closed_count = 0
        for pair_name in list(self.current_positions.keys()):
            if self.close_position("CLOSE_ALL", pair_name, reason):
                closed_count += 1
        logger.info(f"‚úÖ Closed {closed_count} positions")
        return closed_count